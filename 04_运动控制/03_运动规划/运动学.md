# è¿åŠ¨å­¦

è¿åŠ¨å­¦ï¼ˆKinematicsï¼‰æ˜¯ç ”ç©¶æœºå™¨äººè¿åŠ¨è§„å¾‹çš„å­¦ç§‘ï¼Œä¸æ¶‰åŠåŠ›å’Œè´¨é‡ã€‚ç†è§£è¿åŠ¨å­¦æ˜¯è¿›è¡Œæœºå™¨äººæ§åˆ¶å’Œè§„åˆ’çš„åŸºç¡€ã€‚

## ğŸ“‹ ç›®å½•

- [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
- [2. DHå‚æ•°](#2-dhå‚æ•°)
- [3. æ­£è¿åŠ¨å­¦](#3-æ­£è¿åŠ¨å­¦)
- [4. é€†è¿åŠ¨å­¦](#4-é€†è¿åŠ¨å­¦)
- [5. é›…å¯æ¯”çŸ©é˜µ](#5-é›…å¯æ¯”çŸ©é˜µ)
- [6. Pythonå®ç°](#6-pythonå®ç°)

---

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 åˆšä½“è¿åŠ¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åˆšä½“ä½å§¿æè¿°                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ä½å§¿ = ä½ç½® + å§¿æ€ï¼ˆOrientationï¼‰                         â”‚
â”‚                                                             â”‚
â”‚  ä½ç½®ï¼šåœ¨ä¸‰ç»´ç©ºé—´ä¸­çš„åæ ‡ (x, y, z)                         â”‚
â”‚                                                             â”‚
â”‚  å§¿æ€è¡¨ç¤ºæ–¹æ³•ï¼š                                              â”‚
â”‚  1. æ—‹è½¬çŸ©é˜µ R (3x3)                                        â”‚
â”‚  2. æ¬§æ‹‰è§’ (roll, pitch, yaw)                              â”‚
â”‚  3. å››å…ƒæ•° q (qw, qx, qy, qz)                             â”‚
â”‚  4. è½´è§’è¡¨ç¤º (axis, angle)                                 â”‚
â”‚                                                             â”‚
â”‚  é½æ¬¡å˜æ¢çŸ©é˜µ T (4x4)ï¼š                                     â”‚
â”‚       â”Œ           â”                                        â”‚
â”‚       â”‚ R   p     â”‚                                        â”‚
â”‚       â”‚           â”‚                                        â”‚
â”‚       â”‚ 0   1     â”‚                                        â”‚
â”‚       â””           â”˜                                        â”‚
â”‚  å…¶ä¸­ R æ˜¯æ—‹è½¬çŸ©é˜µï¼Œp æ˜¯ä½ç½®å‘é‡                            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ—‹è½¬è¡¨ç¤º

#### æ¬§æ‹‰è§’

```
ZYXæ¬§æ‹‰è§’ï¼ˆRoll-Pitch-Yawï¼‰ï¼š

1. ç»•Zè½´æ—‹è½¬ yaw (Ïˆ)
2. ç»•Yè½´æ—‹è½¬ pitch (Î¸)
3. ç»•Xè½´æ—‹è½¬ roll (Ï†)

æ—‹è½¬çŸ©é˜µï¼š
R = Rz(Ïˆ) * Ry(Î¸) * Rx(Ï†)

é—®é¢˜ï¼šä¸‡å‘é”ï¼ˆGimbal Lockï¼‰
å½“ pitch = Â±90Â° æ—¶ï¼Œä¸¢å¤±ä¸€ä¸ªè‡ªç”±åº¦
```

#### å››å…ƒæ•°

```
å››å…ƒæ•° q = [qw, qx, qy, qz] = qw + qx*i + qy*j + qz*k

çº¦æŸï¼š||q|| = 1ï¼ˆå•ä½å››å…ƒæ•°ï¼‰

ä¼˜åŠ¿ï¼š
â€¢ æ— ä¸‡å‘é”
â€¢ æ’å€¼å¹³æ»‘ï¼ˆSLERPï¼‰
â€¢ è®¡ç®—æ•ˆç‡é«˜
```

---

## 2. DHå‚æ•°

### 2.1 DHå‚æ•°å®šä¹‰

DHå‚æ•°ï¼ˆDenavit-Hartenbergï¼‰æ˜¯ä¸€ç§ç³»ç»Ÿæè¿°æœºå™¨äººå…³èŠ‚å’Œè¿æ†çš„æ–¹æ³•ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DHå‚æ•°å®šä¹‰                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å››ä¸ªå‚æ•°æè¿°ç›¸é‚»è¿æ†å…³ç³»ï¼š                                  â”‚
â”‚                                                             â”‚
â”‚  â€¢ Î¸ (theta)ï¼šå…³èŠ‚è§’ - ç»•ziè½´æ—‹è½¬è§’åº¦ï¼ˆæ—‹è½¬å…³èŠ‚å˜é‡ï¼‰        â”‚
â”‚  â€¢ dï¼šè¿æ†åè· - æ²¿ziè½´çš„ä½ç§»ï¼ˆç§»åŠ¨å…³èŠ‚å˜é‡ï¼‰                â”‚
â”‚  â€¢ aï¼šè¿æ†é•¿åº¦ - æ²¿xiè½´çš„è·ç¦»                               â”‚
â”‚  â€¢ Î± (alpha)ï¼šè¿æ†æ‰­è½¬è§’ - ç»•xiè½´æ—‹è½¬è§’åº¦                   â”‚
â”‚                                                             â”‚
â”‚  è¿æ†å˜æ¢çŸ©é˜µï¼š                                              â”‚
â”‚                                                             â”‚
â”‚       i-1        â”Œ                        â”                â”‚
â”‚      T    =      â”‚ cÎ¸  -sÎ¸cÎ±   sÎ¸sÎ±   a*cÎ¸â”‚                â”‚
â”‚       i          â”‚ sÎ¸   cÎ¸cÎ±  -cÎ¸sÎ±   a*sÎ¸â”‚                â”‚
â”‚                    â”‚ 0    sÎ±     cÎ±      d â”‚                â”‚
â”‚                    â”‚ 0     0      0      1 â”‚                â”‚
â”‚                    â””                        â”˜                â”‚
â”‚  å…¶ä¸­ cÎ¸ = cos(Î¸), sÎ¸ = sin(Î¸)                             â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 DHå‚æ•°è¡¨ç¤ºä¾‹

ä»¥å¸¸è§6è½´æœºæ¢°è‡‚ä¸ºä¾‹ï¼š

| å…³èŠ‚ | Î¸ (Î¸) | d | a | Î± (Î±) |
|------|-------|---|---|-------|
| 1 | Î¸1* | d1 | 0 | -90Â° |
| 2 | Î¸2* | 0 | a2 | 0Â° |
| 3 | Î¸3* | 0 | a3 | 0Â° |
| 4 | Î¸4* | d4 | 0 | -90Â° |
| 5 | Î¸5* | 0 | 0 | 90Â° |
| 6 | Î¸6* | d6 | 0 | 0Â° |

*è¡¨ç¤ºå…³èŠ‚å˜é‡ï¼ˆå¯å˜ï¼‰

---

## 3. æ­£è¿åŠ¨å­¦

### 3.1 å®šä¹‰

**æ­£è¿åŠ¨å­¦ï¼ˆForward Kinematicsï¼‰**ï¼šå·²çŸ¥å…³èŠ‚è§’åº¦ï¼Œè®¡ç®—æœ«ç«¯æ‰§è¡Œå™¨çš„ä½ç½®å’Œå§¿æ€ã€‚

```
è¾“å…¥ï¼šå…³èŠ‚è§’åº¦ q = [Î¸1, Î¸2, ..., Î¸n]
è¾“å‡ºï¼šæœ«ç«¯ä½å§¿ T = [ä½ç½® p, æ—‹è½¬ R]
```

### 3.2 è®¡ç®—æ–¹æ³•

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   æ­£è¿åŠ¨å­¦è®¡ç®—                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  æœ«ç«¯ä½å§¿ = æ‰€æœ‰è¿æ†å˜æ¢çŸ©é˜µçš„ä¹˜ç§¯                           â”‚
â”‚                                                             â”‚
â”‚       0        0   1   2        n-1  n                     â”‚
â”‚      T   =  T   * T   * ... * T                            â”‚
â”‚       n        1   2   3        n    n+1                   â”‚
â”‚                                                             â”‚
â”‚  æˆ–è¡¨ç¤ºä¸ºï¼š                                                  â”‚
â”‚       n                                                       â”‚
â”‚      T   = Î   i-1 T                                          â”‚
â”‚       0   i=1    i                                           â”‚
â”‚                                                             â”‚
â”‚  ä¾‹ï¼š2Ræœºæ¢°è‡‚ï¼ˆä¸¤ä¸ªæ—‹è½¬å…³èŠ‚ï¼‰                                â”‚
â”‚                                                             â”‚
â”‚      x = L1*cos(Î¸1) + L2*cos(Î¸1+Î¸2)                        â”‚
â”‚      y = L1*sin(Î¸1) + L2*sin(Î¸1+Î¸2)                        â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 2Dç¤ºæ„å›¾

```
2Ræœºæ¢°è‡‚æ­£è¿åŠ¨å­¦ï¼š

        æœ«ç«¯æ‰§è¡Œå™¨
            â—
           /|
          / | L2
         /  |
        /Î¸2 |
       â—â”€â”€â”€â”€â”˜
       |   
   L1  |   
       |   
       â—â”€â”€â”€â”€â”€â”
        Î¸1   â”‚
        åŸºåº§  â”‚
```

---

## 4. é€†è¿åŠ¨å­¦

### 4.1 å®šä¹‰

**é€†è¿åŠ¨å­¦ï¼ˆInverse Kinematicsï¼‰**ï¼šå·²çŸ¥æœ«ç«¯æ‰§è¡Œå™¨çš„ç›®æ ‡ä½å§¿ï¼Œè®¡ç®—æ‰€éœ€çš„å…³èŠ‚è§’åº¦ã€‚

```
è¾“å…¥ï¼šç›®æ ‡ä½å§¿ T_target = [ä½ç½® p, æ—‹è½¬ R]
è¾“å‡ºï¼šå…³èŠ‚è§’åº¦ q = [Î¸1, Î¸2, ..., Î¸n]
```

### 4.2 æ±‚è§£æ–¹æ³•

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   é€†è¿åŠ¨å­¦æ±‚è§£æ–¹æ³•                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. è§£ææ³•ï¼ˆAnalyticalï¼‰                                    â”‚
â”‚     â€¢ å‡ ä½•å…³ç³»æ¨å¯¼                                          â”‚
â”‚     â€¢ è®¡ç®—å¿«ï¼Œç²¾åº¦é«˜                                        â”‚
â”‚     â€¢ ä»…é€‚ç”¨äºç®€å•ç»“æ„                                      â”‚
â”‚     â€¢ å¯èƒ½æœ‰é—­å¼è§£æˆ–æ— è§£                                    â”‚
â”‚                                                             â”‚
â”‚  2. æ•°å€¼æ³•ï¼ˆNumericalï¼‰                                     â”‚
â”‚     â€¢ é›…å¯æ¯”è¿­ä»£æ³•                                          â”‚
â”‚     â€¢ ç‰›é¡¿-æ‹‰å¤«æ£®æ³•                                         â”‚
â”‚     â€¢ é€‚ç”¨äºä»»æ„ç»“æ„                                        â”‚
â”‚     â€¢ å¯èƒ½é™·å…¥å±€éƒ¨æœ€ä¼˜                                      â”‚
â”‚                                                             â”‚
â”‚  3. ä¼˜åŒ–æ³•                                                  â”‚
â”‚     â€¢ å°†IKè½¬åŒ–ä¸ºä¼˜åŒ–é—®é¢˜                                    â”‚
â”‚     â€¢ å¯åŠ å…¥çº¦æŸï¼ˆå…³èŠ‚é™ä½ã€é¿éšœï¼‰                          â”‚
â”‚     â€¢ è®¡ç®—è¾ƒæ…¢                                              â”‚
â”‚                                                             â”‚
â”‚  å¤šè§£æ€§ï¼š                                                    â”‚
â”‚  åŒä¸€ä½å§¿å¯èƒ½å¯¹åº”å¤šç»„å…³èŠ‚è§’åº¦                                â”‚
â”‚  é€‰æ‹©å‡†åˆ™ï¼šæœ€æ¥è¿‘å½“å‰å§¿æ€ã€æ— ç¢°æ’ã€æœ€å°èƒ½è€—                  â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.3 2Ræœºæ¢°è‡‚é€†è¿åŠ¨å­¦è§£æè§£

```
ç›®æ ‡ï¼š(x, y)
è‡‚é•¿ï¼šL1, L2

æ­¥éª¤ï¼š
1. è®¡ç®—ç›®æ ‡åˆ°åŸºåº§è·ç¦»
   r = âˆš(xÂ² + yÂ²)
   
2. æ£€æŸ¥å¯è¾¾æ€§
   å¦‚æœ |L1 - L2| > r > L1 + L2ï¼Œåˆ™ä¸å¯è¾¾

3. ä½™å¼¦å®šç†æ±‚Î¸2
   cos(Î¸2) = (xÂ² + yÂ² - L1Â² - L2Â²) / (2*L1*L2)
   Î¸2 = Â±acos(...)  // ä¸¤ç§è§£ï¼šè‚˜ä¸Š/è‚˜ä¸‹

4. æ±‚Î¸1
   Î² = atan2(y, x)
   Ïˆ = atan2(L2*sin(Î¸2), L1 + L2*cos(Î¸2))
   Î¸1 = Î² - Ïˆ
```

---

## 5. é›…å¯æ¯”çŸ©é˜µ

### 5.1 å®šä¹‰

é›…å¯æ¯”çŸ©é˜µæè¿°æœ«ç«¯é€Ÿåº¦ä¸å…³èŠ‚é€Ÿåº¦çš„çº¿æ€§å…³ç³»ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    é›…å¯æ¯”çŸ©é˜µ                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  é€Ÿåº¦å…³ç³»ï¼š                                                  â”‚
â”‚  â”Œ    â”       â”Œ    â”                                       â”‚
â”‚  â”‚ áº‹  â”‚       â”‚     â”‚                                      â”‚
â”‚  â”‚    â”‚  = J *â”‚  qÌ‡  â”‚                                     â”‚
â”‚  â”‚ Ï‰  â”‚       â”‚     â”‚                                      â”‚
â”‚  â””    â”˜       â””    â”˜                                       â”‚
â”‚                                                             â”‚
â”‚  å…¶ä¸­ï¼š                                                      â”‚
â”‚  â€¢ áº‹ï¼šæœ«ç«¯çº¿é€Ÿåº¦ (3x1)                                      â”‚
â”‚  â€¢ Ï‰ï¼šæœ«ç«¯è§’é€Ÿåº¦ (3x1)                                      â”‚
â”‚  â€¢ qÌ‡ï¼šå…³èŠ‚é€Ÿåº¦ (nx1)                                       â”‚
â”‚  â€¢ Jï¼šé›…å¯æ¯”çŸ©é˜µ (6xn)                                      â”‚
â”‚                                                             â”‚
â”‚  é›…å¯æ¯”çŸ©é˜µï¼š                                                â”‚
â”‚       â”Œ      â”                                              â”‚
â”‚       â”‚ J_v  â”‚   (çº¿é€Ÿåº¦éƒ¨åˆ†)                               â”‚
â”‚  J =  â”‚      â”‚                                              â”‚
â”‚       â”‚ J_Ï‰  â”‚   (è§’é€Ÿåº¦éƒ¨åˆ†)                               â”‚
â”‚       â””      â”˜                                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 é›…å¯æ¯”çŸ©é˜µè®¡ç®—

å¯¹äºæ—‹è½¬å…³èŠ‚iï¼š

```
çº¿é€Ÿåº¦åˆ†é‡ï¼šJ_vi = zi Ã— (p_e - pi)

è§’é€Ÿåº¦åˆ†é‡ï¼šJ_Ï‰i = zi

å…¶ä¸­ï¼š
â€¢ ziï¼šç¬¬iä¸ªå…³èŠ‚è½´æ–¹å‘
â€¢ piï¼šç¬¬iä¸ªå…³èŠ‚åŸç‚¹ä½ç½®
â€¢ p_eï¼šæœ«ç«¯æ‰§è¡Œå™¨ä½ç½®
```

### 5.3 å¥‡å¼‚ç‚¹

```
å½“ det(J) = 0 æ—¶ï¼Œæœºå™¨äººå¤„äºå¥‡å¼‚ä½å½¢ï¼š

ç±»å‹ï¼š
1. è¾¹ç•Œå¥‡å¼‚ï¼šæœ«ç«¯åœ¨å·¥ä½œç©ºé—´è¾¹ç•Œ
2. å†…éƒ¨å¥‡å¼‚ï¼šå…³èŠ‚è½´çº¿å…±çº¿

å½±å“ï¼š
â€¢ æŸäº›æ–¹å‘å¤±å»è¿åŠ¨èƒ½åŠ›
â€¢ å…³èŠ‚é€Ÿåº¦å¯èƒ½è¶‹äºæ— ç©·å¤§
â€¢ éœ€è¦é¿å…æˆ–ç‰¹æ®Šå¤„ç†
```

---

## 6. Pythonå®ç°

### 6.1 åŸºç¡€ç±»å®šä¹‰

```python
import numpy as np
from typing import Tuple, List, Optional

class RobotKinematics:
    """æœºå™¨äººè¿åŠ¨å­¦è®¡ç®—ç±»"""
    
    def __init__(self, dh_params: np.ndarray):
        """
        åˆå§‹åŒ–æœºå™¨äººè¿åŠ¨å­¦
        
        Args:
            dh_params: DHå‚æ•°è¡¨ï¼Œshapeä¸º (n_joints, 4)
                      æ¯è¡Œä¸º [a, alpha, d, theta_offset]
        """
        self.dh_params = dh_params
        self.n_joints = len(dh_params)
        
    def dh_transform(self, a: float, alpha: float, d: float, theta: float) -> np.ndarray:
        """
        è®¡ç®—å•ä¸ªDHå˜æ¢çŸ©é˜µ
        
        Args:
            a: è¿æ†é•¿åº¦
            alpha: è¿æ†æ‰­è½¬è§’
            d: è¿æ†åè·
            theta: å…³èŠ‚è§’
        
        Returns:
            4x4 é½æ¬¡å˜æ¢çŸ©é˜µ
        """
        ct = np.cos(theta)
        st = np.sin(theta)
        ca = np.cos(alpha)
        sa = np.sin(alpha)
        
        return np.array([
            [ct,   -st*ca,   st*sa,   a*ct],
            [st,    ct*ca,  -ct*sa,   a*st],
            [0,     sa,      ca,      d   ],
            [0,     0,       0,       1   ]
        ])
    
    def forward_kinematics(self, joint_angles: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """
        æ­£è¿åŠ¨å­¦è®¡ç®—
        
        Args:
            joint_angles: å…³èŠ‚è§’åº¦æ•°ç»„ï¼Œshapeä¸º (n_joints,)
        
        Returns:
            position: æœ«ç«¯ä½ç½® [x, y, z]
            rotation: æœ«ç«¯æ—‹è½¬çŸ©é˜µ 3x3
        """
        T = np.eye(4)
        
        for i in range(self.n_joints):
            a, alpha, d, theta_offset = self.dh_params[i]
            theta = joint_angles[i] + theta_offset
            T_i = self.dh_transform(a, alpha, d, theta)
            T = T @ T_i
        
        position = T[:3, 3]
        rotation = T[:3, :3]
        
        return position, rotation
    
    def compute_jacobian(self, joint_angles: np.ndarray) -> np.ndarray:
        """
        è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
        
        Args:
            joint_angles: å…³èŠ‚è§’åº¦
        
        Returns:
            6 x n_joints é›…å¯æ¯”çŸ©é˜µ
        """
        J = np.zeros((6, self.n_joints))
        
        # è®¡ç®—æ¯ä¸ªå…³èŠ‚åˆ°åŸºåº§çš„å˜æ¢
        T = [np.eye(4)]
        for i in range(self.n_joints):
            a, alpha, d, theta_offset = self.dh_params[i]
            theta = joint_angles[i] + theta_offset
            T_i = self.dh_transform(a, alpha, d, theta)
            T.append(T[-1] @ T_i)
        
        # æœ«ç«¯ä½ç½®
        p_e = T[-1][:3, 3]
        
        # è®¡ç®—é›…å¯æ¯”å„åˆ—
        for i in range(self.n_joints):
            z_i = T[i][:3, 2]  # ç¬¬iä¸ªå…³èŠ‚çš„zè½´
            p_i = T[i][:3, 3]  # ç¬¬iä¸ªå…³èŠ‚çš„ä½ç½®
            
            # çº¿é€Ÿåº¦éƒ¨åˆ†
            J[:3, i] = np.cross(z_i, p_e - p_i)
            # è§’é€Ÿåº¦éƒ¨åˆ†
            J[3:, i] = z_i
        
        return J


class TwoRManipulator:
    """2Rå¹³é¢æœºæ¢°è‡‚ï¼ˆç®€åŒ–æ¨¡å‹ï¼‰"""
    
    def __init__(self, L1: float = 1.0, L2: float = 1.0):
        """
        Args:
            L1: ç¬¬ä¸€è‡‚é•¿åº¦
            L2: ç¬¬äºŒè‡‚é•¿åº¦
        """
        self.L1 = L1
        self.L2 = L2
    
    def forward_kinematics(self, theta1: float, theta2: float) -> Tuple[float, float, float]:
        """
        æ­£è¿åŠ¨å­¦
        
        Args:
            theta1: ç¬¬ä¸€å…³èŠ‚è§’åº¦ï¼ˆå¼§åº¦ï¼‰
            theta2: ç¬¬äºŒå…³èŠ‚è§’åº¦ï¼ˆå¼§åº¦ï¼‰
        
        Returns:
            x, y, phi: æœ«ç«¯ä½ç½®å’Œå§¿æ€è§’
        """
        x = self.L1 * np.cos(theta1) + self.L2 * np.cos(theta1 + theta2)
        y = self.L1 * np.sin(theta1) + self.L2 * np.sin(theta1 + theta2)
        phi = theta1 + theta2  # æœ«ç«¯å§¿æ€è§’
        
        return x, y, phi
    
    def inverse_kinematics(self, x: float, y: float, 
                          elbow_up: bool = True) -> Optional[Tuple[float, float]]:
        """
        é€†è¿åŠ¨å­¦ï¼ˆè§£æè§£ï¼‰
        
        Args:
            x, y: ç›®æ ‡ä½ç½®
            elbow_up: Trueä¸ºè‚˜ä¸Šè§£ï¼ŒFalseä¸ºè‚˜ä¸‹è§£
        
        Returns:
            (theta1, theta2) æˆ– Noneï¼ˆä¸å¯è¾¾ï¼‰
        """
        # ç›®æ ‡è·ç¦»
        r_sq = x**2 + y**2
        r = np.sqrt(r_sq)
        
        # æ£€æŸ¥å¯è¾¾æ€§
        if r > self.L1 + self.L2 or r < abs(self.L1 - self.L2):
            print(f"ç›®æ ‡ ({x}, {y}) ä¸åœ¨å·¥ä½œç©ºé—´å†…")
            return None
        
        # ä½¿ç”¨ä½™å¼¦å®šç†è®¡ç®—theta2
        cos_theta2 = (r_sq - self.L1**2 - self.L2**2) / (2 * self.L1 * self.L2)
        cos_theta2 = np.clip(cos_theta2, -1.0, 1.0)  # æ•°å€¼ç¨³å®šæ€§
        
        if elbow_up:
            theta2 = -np.arccos(cos_theta2)  # è‚˜ä¸Š
        else:
            theta2 = np.arccos(cos_theta2)   # è‚˜ä¸‹
        
        # è®¡ç®—theta1
        beta = np.arctan2(y, x)
        psi = np.arctan2(self.L2 * np.sin(theta2), 
                        self.L1 + self.L2 * np.cos(theta2))
        theta1 = beta - psi
        
        return theta1, theta2
    
    def jacobian(self, theta1: float, theta2: float) -> np.ndarray:
        """
        è®¡ç®—é›…å¯æ¯”çŸ©é˜µ
        
        Returns:
            2x2 é›…å¯æ¯”çŸ©é˜µï¼ˆä»…è€ƒè™‘ä½ç½®ï¼‰
        """
        J = np.array([
            [-self.L1*np.sin(theta1) - self.L2*np.sin(theta1+theta2), 
             -self.L2*np.sin(theta1+theta2)],
            [self.L1*np.cos(theta1) + self.L2*np.cos(theta1+theta2),  
             self.L2*np.cos(theta1+theta2)]
        ])
        return J
    
    def jacobian_inverse_ik(self, x_target: float, y_target: float,
                           theta_init: Tuple[float, float],
                           max_iter: int = 100,
                           tol: float = 1e-4) -> Optional[Tuple[float, float]]:
        """
        ä½¿ç”¨é›…å¯æ¯”è¿­ä»£æ³•æ±‚è§£é€†è¿åŠ¨å­¦
        
        Args:
            x_target, y_target: ç›®æ ‡ä½ç½®
            theta_init: åˆå§‹å…³èŠ‚è§’åº¦
            max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°
            tol: æ”¶æ•›å®¹å·®
        
        Returns:
            (theta1, theta2) æˆ– None
        """
        theta1, theta2 = theta_init
        alpha = 0.5  # æ­¥é•¿
        
        for i in range(max_iter):
            # å½“å‰æœ«ç«¯ä½ç½®
            x, y, _ = self.forward_kinematics(theta1, theta2)
            
            # ä½ç½®è¯¯å·®
            error = np.array([x_target - x, y_target - y])
            
            if np.linalg.norm(error) < tol:
                return theta1, theta2
            
            # é›…å¯æ¯”çŸ©é˜µ
            J = self.jacobian(theta1, theta2)
            
            # é›…å¯æ¯”ä¼ªé€†
            try:
                J_pinv = np.linalg.pinv(J)
            except np.linalg.LinAlgError:
                print("é›…å¯æ¯”çŸ©é˜µå¥‡å¼‚ï¼")
                return None
            
            # æ›´æ–°å…³èŠ‚è§’åº¦
            dtheta = alpha * J_pinv @ error
            theta1 += dtheta[0]
            theta2 += dtheta[1]
        
        print("æœªæ”¶æ•›ï¼")
        return None


# ============ ä½¿ç”¨ç¤ºä¾‹ ============
if __name__ == "__main__":
    import matplotlib.pyplot as plt
    
    # åˆ›å»º2Ræœºæ¢°è‡‚
    robot = TwoRManipulator(L1=1.0, L2=0.8)
    
    # æ­£è¿åŠ¨å­¦æµ‹è¯•
    theta1_test = np.pi/4
    theta2_test = np.pi/6
    x, y, phi = robot.forward_kinematics(theta1_test, theta2_test)
    print(f"æ­£è¿åŠ¨å­¦: Î¸1={np.degrees(theta1_test):.1f}Â°, Î¸2={np.degrees(theta2_test):.1f}Â°")
    print(f"æœ«ç«¯ä½ç½®: ({x:.3f}, {y:.3f}), å§¿æ€: {np.degrees(phi):.1f}Â°")
    
    # é€†è¿åŠ¨å­¦æµ‹è¯•
    x_target, y_target = 1.2, 0.8
    result = robot.inverse_kinematics(x_target, y_target, elbow_up=True)
    if result:
        theta1_ik, theta2_ik = result
        print(f"\né€†è¿åŠ¨å­¦: ç›®æ ‡({x_target}, {y_target})")
        print(f"è§£: Î¸1={np.degrees(theta1_ik):.1f}Â°, Î¸2={np.degrees(theta2_ik):.1f}Â°")
        
        # éªŒè¯
        x_verify, y_verify, _ = robot.forward_kinematics(theta1_ik, theta2_ik)
        print(f"éªŒè¯: ({x_verify:.3f}, {y_verify:.3f})")
    
    # å¯è§†åŒ–å·¥ä½œç©ºé—´
    fig, ax = plt.subplots(figsize=(10, 10))
    
    # ç»˜åˆ¶å·¥ä½œç©ºé—´è¾¹ç•Œ
    theta1_range = np.linspace(0, 2*np.pi, 100)
    for t2 in [0, np.pi]:
        r = np.sqrt(robot.L1**2 + robot.L2**2 + 2*robot.L1*robot.L2*np.cos(t2))
        x_boundary = r * np.cos(theta1_range)
        y_boundary = r * np.sin(theta1_range)
        ax.plot(x_boundary, y_boundary, 'b--', alpha=0.3)
    
    # ç»˜åˆ¶æœºæ¢°è‡‚å§¿æ€
    def draw_robot(theta1, theta2, color='blue'):
        # ç¬¬ä¸€å…³èŠ‚
        x1 = robot.L1 * np.cos(theta1)
        y1 = robot.L1 * np.sin(theta1)
        # æœ«ç«¯
        x2, y2, _ = robot.forward_kinematics(theta1, theta2)
        
        ax.plot([0, x1], [0, y1], 'o-', color=color, linewidth=3, markersize=10)
        ax.plot([x1, x2], [y1, y2], 'o-', color=color, linewidth=3, markersize=10)
        ax.plot(x2, y2, 'r*', markersize=15)
    
    # ç»˜åˆ¶ä¸¤ç§IKè§£
    draw_robot(theta1_test, theta2_test, 'blue')
    ax.set_xlim(-2.5, 2.5)
    ax.set_ylim(-2.5, 2.5)
    ax.set_aspect('equal')
    ax.grid(True)
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_title('2R Manipulator Kinematics')
    plt.savefig('2r_kinematics.png')
    plt.show()
```

### 6.2 UR5æœºæ¢°è‡‚ç¤ºä¾‹

```python
class UR5Kinematics:
    """UR5æœºæ¢°è‡‚è¿åŠ¨å­¦"""
    
    def __init__(self):
        # UR5 DHå‚æ•° (å•ä½ï¼šç±³å’Œå¼§åº¦)
        self.dh_params = np.array([
            # a,      alpha,      d,         theta_offset
            [0.0,     np.pi/2,    0.089159,  0.0],
            [-0.425,  0.0,        0.0,       0.0],
            [-0.39225,0.0,        0.0,       0.0],
            [0.0,     np.pi/2,    0.10915,   0.0],
            [0.0,    -np.pi/2,    0.09465,   0.0],
            [0.0,     0.0,        0.0823,    0.0]
        ])
        self.robot = RobotKinematics(self.dh_params)
    
    def get_end_effector_pose(self, joint_angles: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """è·å–æœ«ç«¯ä½å§¿"""
        return self.robot.forward_kinematics(joint_angles)
    
    def get_jacobian(self, joint_angles: np.ndarray) -> np.ndarray:
        """è·å–é›…å¯æ¯”çŸ©é˜µ"""
        return self.robot.compute_jacobian(joint_angles)


# UR5æµ‹è¯•
if __name__ == "__main__":
    ur5 = UR5Kinematics()
    
    # é›¶ä½å§¿æ€
    joints_zero = np.array([0, 0, 0, 0, 0, 0])
    pos, rot = ur5.get_end_effector_pose(joints_zero)
    print(f"UR5é›¶ä½æœ«ç«¯ä½ç½®: {pos}")
    
    # é›…å¯æ¯”çŸ©é˜µ
    J = ur5.get_jacobian(joints_zero)
    print(f"é›…å¯æ¯”çŸ©é˜µshape: {J.shape}")
    print(f"é›…å¯æ¯”çŸ©é˜µè¡Œåˆ—å¼: {np.linalg.det(J[:3, :3])}")
```

---

## å»¶ä¼¸é˜…è¯»

### æ•™æ
- ã€ŠRobot Modeling and Controlã€‹- Spong, Hutchinson, Vidyasagar
- ã€ŠModern Roboticsã€‹- Lynch & Park

### åœ¨çº¿èµ„æº
- [Modern Roboticså¼€æºæ•™æ](http://hades.mech.northwestern.edu/index.php/Modern_Robotics)
- [Peter Corke Robotics Toolbox](https://petercorke.com/toolboxes/robotics-toolbox/)

---

*æœ¬ç« èŠ‚æŒç»­æ›´æ–°ä¸­...*
