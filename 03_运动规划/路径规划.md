# è·¯å¾„è§„åˆ’

è·¯å¾„è§„åˆ’ï¼ˆPath Planningï¼‰æ˜¯è¿åŠ¨è§„åˆ’çš„åŸºç¡€é—®é¢˜ï¼Œæ—¨åœ¨ä¸ºæœºå™¨äººæ‰¾åˆ°ä¸€æ¡ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æ— ç¢°æ’è·¯å¾„ã€‚

## ğŸ“‹ ç›®å½•

- [1. é—®é¢˜å®šä¹‰](#1-é—®é¢˜å®šä¹‰)
- [2. A* ç®—æ³•](#2-a-ç®—æ³•)
- [3. RRT ç®—æ³•](#3-rrt-ç®—æ³•)
- [4. RRT* ç®—æ³•](#4-rrt-ç®—æ³•)
- [5. åŠ¿åœºæ³•](#5-åŠ¿åœºæ³•)
- [6. ç®—æ³•å¯¹æ¯”](#6-ç®—æ³•å¯¹æ¯”)

---

## 1. é—®é¢˜å®šä¹‰

### 1.1 è·¯å¾„è§„åˆ’é—®é¢˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è·¯å¾„è§„åˆ’é—®é¢˜                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ç»™å®šï¼š                                                      â”‚
â”‚  â€¢ æ„å‹ç©ºé—´ Q                                               â”‚
â”‚  â€¢ è‡ªç”±ç©ºé—´ Q_free = Q \ Q_obs                             â”‚
â”‚  â€¢ èµ·ç‚¹ q_start âˆˆ Q_free                                   â”‚
â”‚  â€¢ ç»ˆç‚¹ q_goal âˆˆ Q_free                                    â”‚
â”‚                                                             â”‚
â”‚  æ±‚è§£ï¼š                                                      â”‚
â”‚  â€¢ è·¯å¾„ Ï€: [0,1] â†’ Q_free                                  â”‚
â”‚  â€¢ æ»¡è¶³ Ï€(0) = q_start, Ï€(1) = q_goal                      â”‚
â”‚                                                             â”‚
â”‚  ä¼˜åŒ–ç›®æ ‡ï¼ˆå¯é€‰ï¼‰ï¼š                                           â”‚
â”‚  â€¢ æœ€çŸ­è·¯å¾„ï¼šmin âˆ«||Ï€'(t)||dt                              â”‚
â”‚  â€¢ æœ€å¹³æ»‘è·¯å¾„ï¼šmin âˆ«||Ï€''(t)||dt                           â”‚
â”‚  â€¢ æœ€å®‰å…¨è·¯å¾„ï¼šmax è·ç¦»éšœç¢ç‰©                                â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 é—®é¢˜åˆ†ç±»

| åˆ†ç±» | ç‰¹ç‚¹ | å…¸å‹ç®—æ³• |
|------|------|---------|
| **ç¦»æ•£ç©ºé—´** | å›¾/ç½‘æ ¼è¡¨ç¤º | A*, Dijkstra, D* |
| **è¿ç»­ç©ºé—´** | æ— ç¦»æ•£åŒ– | RRT, PRM, åŠ¿åœºæ³• |
| **å®Œå¤‡æ€§** | å¿…å®šæ‰¾åˆ°è§£ï¼ˆå¦‚æœå­˜åœ¨ï¼‰ | A*, RRTï¼ˆæ¦‚ç‡å®Œå¤‡ï¼‰ |
| **æœ€ä¼˜æ€§** | æ‰¾åˆ°æœ€ä¼˜è§£ | A*, RRT* |

---

## 2. A* ç®—æ³•

### 2.1 ç®—æ³•åŸç†

A* æ˜¯æœ€ç»å…¸çš„å›¾æœç´¢ç®—æ³•ï¼Œç»“åˆäº† Dijkstra çš„æœ€ä¼˜æ€§å’Œå¯å‘å¼æœç´¢çš„æ•ˆç‡ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    A* ç®—æ³•æ ¸å¿ƒ                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  è¯„ä¼°å‡½æ•°ï¼šf(n) = g(n) + h(n)                               â”‚
â”‚                                                             â”‚
â”‚  â€¢ g(n)ï¼šä»èµ·ç‚¹åˆ°èŠ‚ç‚¹nçš„å®é™…ä»£ä»·                             â”‚
â”‚  â€¢ h(n)ï¼šä»èŠ‚ç‚¹nåˆ°ç»ˆç‚¹çš„å¯å‘å¼ä¼°è®¡                           â”‚
â”‚  â€¢ f(n)ï¼šç»è¿‡èŠ‚ç‚¹nçš„æ€»ä¼°è®¡ä»£ä»·                               â”‚
â”‚                                                             â”‚
â”‚  å¯å‘å¼å‡½æ•°é€‰æ‹©ï¼š                                            â”‚
â”‚  â€¢ æ›¼å“ˆé¡¿è·ç¦»ï¼šh = |x1-x2| + |y1-y2|   ï¼ˆ4è¿é€šï¼‰            â”‚
â”‚  â€¢ æ¬§å‡ é‡Œå¾—è·ç¦»ï¼šh = âˆš((x1-x2)Â² + (y1-y2)Â²)  ï¼ˆ8è¿é€šï¼‰       â”‚
â”‚  â€¢ åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼šh = max(|x1-x2|, |y1-y2|)                  â”‚
â”‚                                                             â”‚
â”‚  å¯æ¥çº³æ€§ï¼ˆAdmissibilityï¼‰ï¼š                                 â”‚
â”‚  â€¢ h(n) â‰¤ h*(n) ï¼ˆä¸è¶…è¿‡çœŸå®ä»£ä»·ï¼‰                          â”‚
â”‚  â€¢ ä¿è¯æ‰¾åˆ°æœ€ä¼˜è·¯å¾„                                          â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 ç®—æ³•æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           A* ç®—æ³•æµç¨‹                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                         â”‚
â”‚  1. åˆå§‹åŒ–                              â”‚
â”‚     Open = {start}                      â”‚
â”‚     Closed = {}                         â”‚
â”‚     g[start] = 0                        â”‚
â”‚                                         â”‚
â”‚  2. å¾ªç¯ç›´åˆ° Open ä¸ºç©º                  â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚     â”‚ a. å–å‡º f å€¼æœ€å°çš„èŠ‚ç‚¹ n      â”‚   â”‚
â”‚     â”‚    ä» Open ç§»åˆ° Closed        â”‚   â”‚
â”‚     â”‚                              â”‚   â”‚
â”‚     â”‚ b. è‹¥ n == goalï¼Œè¿”å›è·¯å¾„     â”‚   â”‚
â”‚     â”‚                              â”‚   â”‚
â”‚     â”‚ c. å¯¹æ¯ä¸ªé‚»å±… mï¼š             â”‚   â”‚
â”‚     â”‚    è‹¥ m âˆˆ Closedï¼Œè·³è¿‡       â”‚   â”‚
â”‚     â”‚    è®¡ç®— tentative_g = g[n]+d â”‚   â”‚
â”‚     â”‚    è‹¥ m âˆ‰ Open æˆ–æ›´ä¼˜ï¼š       â”‚   â”‚
â”‚     â”‚       æ›´æ–° g[m], f[m]        â”‚   â”‚
â”‚     â”‚       è®¾ç½® parent[m] = n     â”‚   â”‚
â”‚     â”‚       å°† m åŠ å…¥ Open         â”‚   â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                         â”‚
â”‚  3. è¿”å›å¤±è´¥ï¼ˆæ— è·¯å¾„ï¼‰                  â”‚
â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.3 Pythonå®ç°

```python
import numpy as np
from heapq import heappush, heappop
from typing import List, Tuple, Optional

class AStar:
    """A*è·¯å¾„è§„åˆ’ç®—æ³•"""
    
    def __init__(self, grid: np.ndarray):
        """
        åˆå§‹åŒ–A*è§„åˆ’å™¨
        
        Args:
            grid: 2Dæ …æ ¼åœ°å›¾ï¼Œ0è¡¨ç¤ºå¯é€šè¡Œï¼Œ1è¡¨ç¤ºéšœç¢ç‰©
        """
        self.grid = grid
        self.rows, self.cols = grid.shape
        
        # 8ä¸ªæ–¹å‘ï¼šä¸Šä¸‹å·¦å³ + 4ä¸ªå¯¹è§’çº¿
        self.directions = [
            (0, 1), (0, -1), (1, 0), (-1, 0),  # 4è¿é€š
            (1, 1), (1, -1), (-1, 1), (-1, -1)  # å¯¹è§’çº¿
        ]
        
        # å¯¹è§’çº¿ç§»åŠ¨ä»£ä»·ä¸ºâˆš2ï¼Œç›´çº¿ä¸º1
        self.move_cost = [1, 1, 1, 1, 
                          np.sqrt(2), np.sqrt(2), np.sqrt(2), np.sqrt(2)]
    
    def heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:
        """æ¬§å‡ é‡Œå¾—è·ç¦»å¯å‘å¼"""
        return np.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)
    
    def is_valid(self, pos: Tuple[int, int]) -> bool:
        """æ£€æŸ¥ä½ç½®æ˜¯å¦æœ‰æ•ˆ"""
        x, y = pos
        return (0 <= x < self.rows and 
                0 <= y < self.cols and 
                self.grid[x, y] == 0)
    
    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int, float]]:
        """è·å–æœ‰æ•ˆé‚»å±…åŠå…¶ç§»åŠ¨ä»£ä»·"""
        neighbors = []
        x, y = pos
        
        for (dx, dy), cost in zip(self.directions, self.move_cost):
            nx, ny = x + dx, y + dy
            if self.is_valid((nx, ny)):
                # å¯¹è§’çº¿ç§»åŠ¨æ—¶æ£€æŸ¥æ˜¯å¦ç©¿è¿‡è§’è½
                if abs(dx) + abs(dy) == 2:  # å¯¹è§’çº¿ç§»åŠ¨
                    if self.grid[x + dx, y] == 0 and self.grid[x, y + dy] == 0:
                        neighbors.append(((nx, ny), cost))
                else:
                    neighbors.append(((nx, ny), cost))
        
        return neighbors
    
    def plan(self, start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:
        """
        æ‰§è¡ŒA*è§„åˆ’
        
        Args:
            start: èµ·å§‹ä½ç½® (row, col)
            goal: ç›®æ ‡ä½ç½® (row, col)
            
        Returns:
            è·¯å¾„åˆ—è¡¨ï¼Œè‹¥æ— æ³•åˆ°è¾¾åˆ™è¿”å›None
        """
        if not self.is_valid(start) or not self.is_valid(goal):
            return None
        
        # ä¼˜å…ˆé˜Ÿåˆ—ï¼š(få€¼, è®¡æ•°å™¨, ä½ç½®)
        open_set = []
        heappush(open_set, (0, 0, start))
        
        # è®°å½•
        came_from = {start: None}
        g_score = {start: 0}
        f_score = {start: self.heuristic(start, goal)}
        
        closed_set = set()
        counter = 0
        
        while open_set:
            _, _, current = heappop(open_set)
            
            if current in closed_set:
                continue
            
            if current == goal:
                # é‡æ„è·¯å¾„
                path = []
                while current is not None:
                    path.append(current)
                    current = came_from[current]
                return path[::-1]
            
            closed_set.add(current)
            
            for (neighbor, cost) in self.get_neighbors(current):
                if neighbor in closed_set:
                    continue
                
                tentative_g = g_score[current] + cost
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g
                    f_score[neighbor] = tentative_g + self.heuristic(neighbor, goal)
                    counter += 1
                    heappush(open_set, (f_score[neighbor], counter, neighbor))
        
        return None  # æœªæ‰¾åˆ°è·¯å¾„
    
    def smooth_path(self, path: List[Tuple[int, int]], iterations: int = 100) -> List[Tuple[int, int]]:
        """è·¯å¾„å¹³æ»‘å¤„ç†ï¼ˆæ¢¯åº¦ä¸‹é™æ³•ï¼‰"""
        if len(path) <= 2:
            return path
        
        # è½¬æ¢ä¸ºè¿ç»­åæ ‡
        path = np.array(path, dtype=float)
        smoothed = path.copy()
        
        # æƒé‡å‚æ•°
        weight_data = 0.5  # ä¿æŒåŸå§‹è·¯å¾„
        weight_smooth = 0.3  # å¹³æ»‘åº¦
        
        for _ in range(iterations):
            for i in range(1, len(path) - 1):
                for j in range(2):  # xå’Œy
                    smoothed[i, j] += weight_data * (path[i, j] - smoothed[i, j])
                    smoothed[i, j] += weight_smooth * (smoothed[i-1, j] + smoothed[i+1, j] - 2 * smoothed[i, j])
        
        return smoothed.tolist()


# ============ ä½¿ç”¨ç¤ºä¾‹ ============
if __name__ == "__main__":
    import matplotlib.pyplot as plt
    
    # åˆ›å»ºæµ‹è¯•åœ°å›¾
    grid_size = 50
    grid = np.zeros((grid_size, grid_size))
    
    # æ·»åŠ éšœç¢ç‰©
    grid[10:30, 20:25] = 1  # å‚ç›´å¢™
    grid[15:20, 25:40] = 1  # æ°´å¹³å¢™
    
    # åˆ›å»ºè§„åˆ’å™¨
    planner = AStar(grid)
    
    # è§„åˆ’è·¯å¾„
    start = (5, 5)
    goal = (45, 45)
    path = planner.plan(start, goal)
    
    if path:
        print(f"æ‰¾åˆ°è·¯å¾„ï¼Œé•¿åº¦: {len(path)}")
        
        # å¯è§†åŒ–
        plt.figure(figsize=(10, 10))
        plt.imshow(grid, cmap='binary')
        
        path_array = np.array(path)
        plt.plot(path_array[:, 1], path_array[:, 0], 'b-', linewidth=2, label='A* Path')
        plt.plot(start[1], start[0], 'go', markersize=15, label='Start')
        plt.plot(goal[1], goal[0], 'ro', markersize=15, label='Goal')
        
        plt.legend()
        plt.title('A* Path Planning')
        plt.xlabel('X')
        plt.ylabel('Y')
        plt.grid(True)
        plt.savefig('astar_path.png')
        plt.show()
    else:
        print("æœªæ‰¾åˆ°è·¯å¾„ï¼")
```

---

## 3. RRT ç®—æ³•

### 3.1 ç®—æ³•åŸç†

RRTï¼ˆRapidly-exploring Random Treeï¼‰æ˜¯ä¸€ç§åŸºäºé‡‡æ ·çš„è·¯å¾„è§„åˆ’ç®—æ³•ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RRT ç®—æ³•æ ¸å¿ƒ                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  æ ¸å¿ƒæ€æƒ³ï¼š                                                  â”‚
â”‚  é€šè¿‡éšæœºé‡‡æ ·ï¼Œåœ¨æ„å‹ç©ºé—´ä¸­æ„å»ºä¸€æ£µå¿«é€Ÿæ¢ç´¢çš„æ ‘               â”‚
â”‚                                                             â”‚
â”‚  ä¼˜åŠ¿ï¼š                                                      â”‚
â”‚  â€¢ å¯å¤„ç†é«˜ç»´ç©ºé—´                                            â”‚
â”‚  â€¢ æ— éœ€æ˜¾å¼æ„å»ºéšœç¢ç‰©è¾¹ç•Œ                                    â”‚
â”‚  â€¢ æ¦‚ç‡å®Œå¤‡ï¼ˆé‡‡æ ·è¶³å¤Ÿå¤šå¿…å®šæ‰¾åˆ°è§£ï¼‰                          â”‚
â”‚                                                             â”‚
â”‚  åŠ£åŠ¿ï¼š                                                      â”‚
â”‚  â€¢ è·¯å¾„é€šå¸¸ä¸æ˜¯æœ€ä¼˜                                          â”‚
â”‚  â€¢ åœ¨ç‹­çª„é€šé“ä¸­æ•ˆç‡è¾ƒä½                                      â”‚
â”‚                                                             â”‚
â”‚  ç®—æ³•æ­¥éª¤ï¼š                                                  â”‚
â”‚  1. ä»èµ·ç‚¹åˆå§‹åŒ–æ ‘ T = {q_start}                            â”‚
â”‚  2. åœ¨è‡ªç”±ç©ºé—´éšæœºé‡‡æ · q_rand                               â”‚
â”‚  3. æ‰¾åˆ°æ ‘ä¸­æœ€è¿‘èŠ‚ç‚¹ q_near                                  â”‚
â”‚  4. ä» q_near å‘ q_rand æ‰©å±•æ­¥é•¿ step_size å¾—åˆ° q_new       â”‚
â”‚  5. è‹¥æ— ç¢°æ’ï¼Œå°† q_new åŠ å…¥æ ‘                                â”‚
â”‚  6. é‡å¤ç›´åˆ° q_new æ¥è¿‘ q_goal                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 å¯è§†åŒ–ç¤ºæ„å›¾

```
         q_goal
            â˜…
           /|\
          / | \
         /  |  \
        /   |   \
       /    |    \
      /     |     \
     /    q_new    \
    /       |       \
   /        |        \
  /      q_near      \
 â—--------â—-----------â—--------â—
q_start   \         / 
           \       /
            \     /
             \   /
              \ /
               â— q_rand
               
RRTé€šè¿‡éšæœºé‡‡æ ·é€æ­¥æ‰©å±•æ ‘ï¼Œç›´åˆ°æ¥è¿‘ç›®æ ‡
```

### 3.3 Pythonå®ç°

```python
import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Optional

class RRT:
    """RRTè·¯å¾„è§„åˆ’ç®—æ³•"""
    
    def __init__(self, 
                 start: Tuple[float, float],
                 goal: Tuple[float, float],
                 obstacle_list: List[Tuple[float, float, float]],
                 bounds: Tuple[float, float, float, float],
                 step_size: float = 0.5,
                 goal_sample_rate: float = 0.1,
                 max_iter: int = 5000):
        """
        åˆå§‹åŒ–RRTè§„åˆ’å™¨
        
        Args:
            start: èµ·å§‹ç‚¹ (x, y)
            goal: ç›®æ ‡ç‚¹ (x, y)
            obstacle_list: éšœç¢ç‰©åˆ—è¡¨ [(x, y, radius), ...]
            bounds: è¾¹ç•Œ (x_min, x_max, y_min, y_max)
            step_size: æ‰©å±•æ­¥é•¿
            goal_sample_rate: ç›´æ¥é‡‡æ ·ç›®æ ‡çš„æ¦‚ç‡
            max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°
        """
        self.start = np.array(start)
        self.goal = np.array(goal)
        self.obstacle_list = obstacle_list
        self.bounds = bounds
        self.step_size = step_size
        self.goal_sample_rate = goal_sample_rate
        self.max_iter = max_iter
        
        # æ ‘ç»“æ„ï¼šèŠ‚ç‚¹åˆ—è¡¨å’Œè¾¹åˆ—è¡¨
        self.nodes = [self.start]
        self.parent = {0: -1}  # æ ¹èŠ‚ç‚¹æ²¡æœ‰çˆ¶èŠ‚ç‚¹
        
    def get_random_point(self) -> np.ndarray:
        """åœ¨è¾¹ç•Œå†…éšæœºé‡‡æ ·ä¸€ä¸ªç‚¹"""
        if np.random.random() < self.goal_sample_rate:
            return self.goal.copy()
        
        x = np.random.uniform(self.bounds[0], self.bounds[1])
        y = np.random.uniform(self.bounds[2], self.bounds[3])
        return np.array([x, y])
    
    def get_nearest_node(self, point: np.ndarray) -> int:
        """æ‰¾åˆ°æ ‘ä¸­è·ç¦»ç»™å®šç‚¹æœ€è¿‘çš„èŠ‚ç‚¹ç´¢å¼•"""
        distances = [np.linalg.norm(node - point) for node in self.nodes]
        return np.argmin(distances)
    
    def steer(self, from_node: np.ndarray, to_point: np.ndarray) -> np.ndarray:
        """ä»from_nodeå‘to_pointæ‰©å±•ä¸€æ­¥"""
        direction = to_point - from_node
        dist = np.linalg.norm(direction)
        
        if dist <= self.step_size:
            return to_point.copy()
        else:
            return from_node + self.step_size * direction / dist
    
    def is_collision_free(self, point1: np.ndarray, point2: np.ndarray) -> bool:
        """æ£€æŸ¥ä»point1åˆ°point2çš„è·¯å¾„æ˜¯å¦æ— ç¢°æ’"""
        # æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨è¾¹ç•Œå†…
        if not (self.bounds[0] <= point2[0] <= self.bounds[1] and
                self.bounds[2] <= point2[1] <= self.bounds[3]):
            return False
        
        # æ£€æŸ¥æ˜¯å¦ä¸ä»»ä½•éšœç¢ç‰©ç¢°æ’
        for (ox, oy, radius) in self.obstacle_list:
            obstacle_center = np.array([ox, oy])
            
            # è®¡ç®—çº¿æ®µåˆ°åœ†å¿ƒçš„æœ€çŸ­è·ç¦»
            line_vec = point2 - point1
            point_vec = obstacle_center - point1
            line_len = np.linalg.norm(line_vec)
            
            if line_len < 1e-6:
                # ä¸¤ç‚¹é‡åˆ
                dist = np.linalg.norm(point_vec)
            else:
                # æŠ•å½±åˆ°çº¿æ®µ
                line_unitvec = line_vec / line_len
                proj_length = np.dot(point_vec, line_unitvec)
                proj_length = max(0, min(line_len, proj_length))
                closest_point = point1 + proj_length * line_unitvec
                dist = np.linalg.norm(obstacle_center - closest_point)
            
            if dist <= radius:
                return False
        
        return True
    
    def plan(self) -> Optional[List[np.ndarray]]:
        """æ‰§è¡ŒRRTè§„åˆ’"""
        for i in range(self.max_iter):
            # éšæœºé‡‡æ ·
            q_rand = self.get_random_point()
            
            # æ‰¾æœ€è¿‘èŠ‚ç‚¹
            nearest_idx = self.get_nearest_node(q_rand)
            q_near = self.nodes[nearest_idx]
            
            # å‘é‡‡æ ·ç‚¹æ‰©å±•
            q_new = self.steer(q_near, q_rand)
            
            # ç¢°æ’æ£€æµ‹
            if self.is_collision_free(q_near, q_new):
                # æ·»åŠ æ–°èŠ‚ç‚¹
                self.nodes.append(q_new)
                self.parent[len(self.nodes) - 1] = nearest_idx
                
                # æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡
                if np.linalg.norm(q_new - self.goal) <= self.step_size:
                    if self.is_collision_free(q_new, self.goal):
                        # æ·»åŠ ç›®æ ‡èŠ‚ç‚¹
                        self.nodes.append(self.goal)
                        self.parent[len(self.nodes) - 1] = len(self.nodes) - 2
                        
                        # é‡æ„è·¯å¾„
                        return self.extract_path()
        
        return None
    
    def extract_path(self) -> List[np.ndarray]:
        """ä»æ ‘ä¸­æå–è·¯å¾„"""
        path = []
        node_idx = len(self.nodes) - 1
        
        while node_idx != -1:
            path.append(self.nodes[node_idx])
            node_idx = self.parent[node_idx]
        
        return path[::-1]


# ============ ä½¿ç”¨ç¤ºä¾‹ ============
if __name__ == "__main__":
    # è®¾ç½®å‚æ•°
    start = (5, 5)
    goal = (45, 45)
    bounds = (0, 50, 0, 50)
    
    # åˆ›å»ºéšœç¢ç‰©ï¼ˆåœ†å½¢ï¼‰
    obstacles = [
        (20, 20, 5),
        (30, 30, 5),
        (25, 35, 4),
        (15, 25, 3),
    ]
    
    # åˆ›å»ºè§„åˆ’å™¨å¹¶è§„åˆ’
    rrt = RRT(start, goal, obstacles, bounds, step_size=2.0)
    path = rrt.plan()
    
    if path:
        print(f"æ‰¾åˆ°è·¯å¾„ï¼ŒèŠ‚ç‚¹æ•°: {len(path)}")
        
        # å¯è§†åŒ–
        plt.figure(figsize=(10, 10))
        
        # ç»˜åˆ¶éšœç¢ç‰©
        for (ox, oy, radius) in obstacles:
            circle = plt.Circle((ox, oy), radius, color='red', alpha=0.6)
            plt.gca().add_patch(circle)
        
        # ç»˜åˆ¶æ ‘
        for i, node in enumerate(rrt.nodes):
            parent_idx = rrt.parent[i]
            if parent_idx >= 0:
                parent = rrt.nodes[parent_idx]
                plt.plot([parent[0], node[0]], [parent[1], node[1]], 'g-', alpha=0.3)
        
        # ç»˜åˆ¶è·¯å¾„
        path_array = np.array(path)
        plt.plot(path_array[:, 0], path_array[:, 1], 'b-', linewidth=2, label='RRT Path')
        
        # ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
        plt.plot(start[0], start[1], 'go', markersize=15, label='Start')
        plt.plot(goal[0], goal[1], 'r*', markersize=20, label='Goal')
        
        plt.xlim(bounds[0], bounds[1])
        plt.ylim(bounds[2], bounds[3])
        plt.legend()
        plt.title('RRT Path Planning')
        plt.grid(True)
        plt.savefig('rrt_path.png')
        plt.show()
    else:
        print("æœªæ‰¾åˆ°è·¯å¾„ï¼")
```

---

## 4. RRT* ç®—æ³•

### 4.1 ç®—æ³•åŸç†

RRT* æ˜¯ RRT çš„æ”¹è¿›ç‰ˆæœ¬ï¼Œå¢åŠ äº†**é‡æ–°è¿æ¥ï¼ˆRewiringï¼‰**æœºåˆ¶ï¼Œèƒ½å¤Ÿæ¸è¿›æ”¶æ•›åˆ°æœ€ä¼˜è·¯å¾„ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    RRT* æ”¹è¿›                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ç›¸æ¯”RRTçš„æ”¹è¿›ï¼š                                             â”‚
â”‚  1. é€‰æ‹©çˆ¶èŠ‚ç‚¹ï¼šåœ¨åŠå¾„rå†…é€‰æ‹©ä»£ä»·æœ€å°çš„èŠ‚ç‚¹ä½œä¸ºçˆ¶èŠ‚ç‚¹         â”‚
â”‚  2. é‡æ–°è¿æ¥ï¼šæ£€æŸ¥æ–°èŠ‚ç‚¹èƒ½å¦é™ä½é‚»å±…èŠ‚ç‚¹çš„ä»£ä»·               â”‚
â”‚                                                             â”‚
â”‚  ä¼ªä»£ç ï¼š                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ NearNeighbors = FindNearNodes(q_new, radius)        â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚ // é€‰æ‹©æœ€ä¼˜çˆ¶èŠ‚ç‚¹                                    â”‚   â”‚
â”‚  â”‚ for q_near in NearNeighbors:                        â”‚   â”‚
â”‚  â”‚     if Cost(q_near) + d(q_near, q_new) < min_cost:  â”‚   â”‚
â”‚  â”‚         q_parent = q_near                           â”‚   â”‚
â”‚  â”‚         min_cost = Cost(q_near) + d(...)           â”‚   â”‚
â”‚  â”‚                                                      â”‚   â”‚
â”‚  â”‚ // é‡æ–°è¿æ¥é‚»å±…                                      â”‚   â”‚
â”‚  â”‚ for q_near in NearNeighbors:                        â”‚   â”‚
â”‚  â”‚     if Cost(q_new) + d(q_new, q_near) < Cost(q_near):â”‚   â”‚
â”‚  â”‚         Reparent(q_near, q_new)                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  æ¸è¿›æœ€ä¼˜æ€§ï¼š                                                â”‚
â”‚  éšç€é‡‡æ ·ç‚¹æ•°é‡å¢åŠ ï¼Œè·¯å¾„ä»£ä»·æ”¶æ•›åˆ°æœ€ä¼˜                       â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 ä»£ä»·å‡½æ•°

```
Cost(q) = Cost(parent(q)) + distance(parent(q), q)

é€‰æ‹©çˆ¶èŠ‚ç‚¹çš„ç›®æ ‡ï¼šminimize Cost(q_new)
```

### 4.3 Pythonå®ç°

```python
class RRTStar(RRT):
    """RRT*è·¯å¾„è§„åˆ’ç®—æ³• - ç»§æ‰¿è‡ªRRT"""
    
    def __init__(self, 
                 start: Tuple[float, float],
                 goal: Tuple[float, float],
                 obstacle_list: List[Tuple[float, float, float]],
                 bounds: Tuple[float, float, float, float],
                 step_size: float = 0.5,
                 goal_sample_rate: float = 0.1,
                 max_iter: int = 5000,
                 search_radius: float = 10.0):
        """
        Args:
            search_radius: æœç´¢é‚»å±…çš„åŠå¾„
        """
        super().__init__(start, goal, obstacle_list, bounds, 
                        step_size, goal_sample_rate, max_iter)
        self.search_radius = search_radius
        self.cost = [0.0]  # æ¯ä¸ªèŠ‚ç‚¹çš„ä»£ä»·
        
    def get_near_nodes(self, point: np.ndarray) -> List[int]:
        """æ‰¾åˆ°æœç´¢åŠå¾„å†…çš„æ‰€æœ‰èŠ‚ç‚¹"""
        distances = [np.linalg.norm(node - point) for node in self.nodes]
        return [i for i, d in enumerate(distances) if d <= self.search_radius]
    
    def compute_cost(self, node_idx: int) -> float:
        """è®¡ç®—ä»èµ·ç‚¹åˆ°æŸèŠ‚ç‚¹çš„ä»£ä»·"""
        cost = 0.0
        idx = node_idx
        
        while self.parent[idx] != -1:
            cost += np.linalg.norm(self.nodes[idx] - self.nodes[self.parent[idx]])
            idx = self.parent[idx]
        
        return cost
    
    def choose_parent(self, q_new: np.ndarray, near_nodes: List[int]) -> Tuple[int, float]:
        """é€‰æ‹©æœ€ä¼˜çˆ¶èŠ‚ç‚¹"""
        min_cost = float('inf')
        best_parent = -1
        
        for near_idx in near_nodes:
            q_near = self.nodes[near_idx]
            if self.is_collision_free(q_near, q_new):
                cost = self.compute_cost(near_idx) + np.linalg.norm(q_near - q_new)
                if cost < min_cost:
                    min_cost = cost
                    best_parent = near_idx
        
        return best_parent, min_cost
    
    def rewire(self, q_new_idx: int, near_nodes: List[int]):
        """é‡æ–°è¿æ¥ï¼šæ£€æŸ¥æ–°èŠ‚ç‚¹èƒ½å¦é™ä½é‚»å±…çš„ä»£ä»·"""
        q_new = self.nodes[q_new_idx]
        cost_to_new = self.compute_cost(q_new_idx)
        
        for near_idx in near_nodes:
            if near_idx == q_new_idx:
                continue
            
            q_near = self.nodes[near_idx]
            potential_cost = cost_to_new + np.linalg.norm(q_new - q_near)
            
            if potential_cost < self.compute_cost(near_idx):
                if self.is_collision_free(q_new, q_near):
                    # é‡æ–°è®¾ç½®çˆ¶èŠ‚ç‚¹
                    self.parent[near_idx] = q_new_idx
    
    def plan(self) -> Optional[List[np.ndarray]]:
        """æ‰§è¡ŒRRT*è§„åˆ’"""
        for i in range(self.max_iter):
            # éšæœºé‡‡æ ·
            q_rand = self.get_random_point()
            
            # æ‰¾æœ€è¿‘èŠ‚ç‚¹
            nearest_idx = self.get_nearest_node(q_rand)
            q_near = self.nodes[nearest_idx]
            
            # å‘é‡‡æ ·ç‚¹æ‰©å±•
            q_new = self.steer(q_near, q_rand)
            
            # æ‰¾åˆ°é™„è¿‘çš„èŠ‚ç‚¹
            near_nodes = self.get_near_nodes(q_new)
            
            # é€‰æ‹©æœ€ä¼˜çˆ¶èŠ‚ç‚¹
            if near_nodes:
                best_parent, min_cost = self.choose_parent(q_new, near_nodes)
                if best_parent >= 0 and self.is_collision_free(self.nodes[best_parent], q_new):
                    # æ·»åŠ æ–°èŠ‚ç‚¹
                    self.nodes.append(q_new)
                    new_idx = len(self.nodes) - 1
                    self.parent[new_idx] = best_parent
                    self.cost.append(min_cost)
                    
                    # é‡æ–°è¿æ¥
                    self.rewire(new_idx, near_nodes)
                    
                    # æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡
                    if np.linalg.norm(q_new - self.goal) <= self.step_size:
                        if self.is_collision_free(q_new, self.goal):
                            self.nodes.append(self.goal)
                            goal_idx = len(self.nodes) - 1
                            self.parent[goal_idx] = new_idx
                            return self.extract_path()
        
        return None


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    obstacles = [(20, 20, 5), (30, 30, 5), (25, 35, 4)]
    
    rrt_star = RRTStar(
        start=(5, 5), 
        goal=(45, 45),
        obstacle_list=obstacles,
        bounds=(0, 50, 0, 50),
        step_size=2.0,
        search_radius=15.0
    )
    
    path = rrt_star.plan()
    if path:
        print(f"RRT* æ‰¾åˆ°è·¯å¾„ï¼Œé•¿åº¦: {len(path)}")
```

---

## 5. åŠ¿åœºæ³•

### 5.1 ç®—æ³•åŸç†

åŠ¿åœºæ³•ï¼ˆPotential Field Methodï¼‰å°†ç¯å¢ƒå»ºæ¨¡ä¸ºåŠ¿åœºï¼Œç›®æ ‡ç‚¹äº§ç”Ÿå¼•åŠ›ï¼Œéšœç¢ç‰©äº§ç”Ÿæ–¥åŠ›ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åŠ¿åœºæ³•åŸç†                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  æ€»åŠ¿åœº = å¼•åŠ›åœº + æ–¥åŠ›åœº                                   â”‚
â”‚  U(q) = U_att(q) + U_rep(q)                                â”‚
â”‚                                                             â”‚
â”‚  å¼•åŠ›åœºï¼ˆç›®æ ‡ç‚¹ï¼‰ï¼š                                          â”‚
â”‚  U_att(q) = 1/2 * k_att * ||q - q_goal||Â²                  â”‚
â”‚  F_att(q) = -âˆ‡U_att = k_att * (q_goal - q)                 â”‚
â”‚                                                             â”‚
â”‚  æ–¥åŠ›åœºï¼ˆéšœç¢ç‰©ï¼‰ï¼š                                          â”‚
â”‚  U_rep(q) = { 1/2 * k_rep * (1/Ï - 1/Ïâ‚€)Â²  if Ï â‰¤ Ïâ‚€      â”‚
â”‚             { 0                              otherwise      â”‚
â”‚  F_rep(q) = -âˆ‡U_rep                                         â”‚
â”‚                                                             â”‚
â”‚  åˆåŠ›ï¼šF_total = F_att + Î£F_rep                            â”‚
â”‚  è¿åŠ¨æ–¹å‘ï¼šq_new = q + step * F_total / ||F_total||        â”‚
â”‚                                                             â”‚
â”‚  é—®é¢˜ï¼š                                                      â”‚
â”‚  â€¢ å±€éƒ¨æå°å€¼ï¼šå¯èƒ½é™·å…¥éç›®æ ‡çš„æå°åŠ¿èƒ½ç‚¹                    â”‚
â”‚  â€¢ æŒ¯è¡ï¼šåœ¨ç‹­çª„é€šé“ä¸­æ¥å›éœ‡è¡                               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 å¯è§†åŒ–

```
            ç›®æ ‡ç‚¹ï¼ˆå¼•åŠ›ä¸­å¿ƒï¼‰
                â˜…
               â†— â†‘ â†–
              /  |  \
             /   |   \
            /    |    \
           â†     |     â†’
          /      |      \
         /       |       \
        /      éšœç¢ç‰©     \
       /      â•”â•â•â•â•—      \
      /       â•‘   â•‘       \
     â†        â•‘   â•‘        â†’
              â•šâ•â•â•â•
                â†‘
               æ–¥åŠ›

æœºå™¨äººä»èµ·ç‚¹å‡ºå‘ï¼Œè¢«ç›®æ ‡å¸å¼•ï¼Œè¢«éšœç¢ç‰©æ’æ–¥
```

### 5.3 Pythonå®ç°

```python
import numpy as np
from typing import List, Tuple

class PotentialFieldPlanner:
    """åŠ¿åœºæ³•è·¯å¾„è§„åˆ’"""
    
    def __init__(self, 
                 goal: Tuple[float, float],
                 obstacles: List[Tuple[float, float, float]],
                 k_att: float = 1.0,
                 k_rep: float = 100.0,
                 rho_0: float = 5.0,
                 step_size: float = 0.5):
        """
        Args:
            goal: ç›®æ ‡ä½ç½®
            obstacles: éšœç¢ç‰©åˆ—è¡¨ [(x, y, radius), ...]
            k_att: å¼•åŠ›å¢ç›Š
            k_rep: æ–¥åŠ›å¢ç›Š
            rho_0: éšœç¢ç‰©å½±å“èŒƒå›´
            step_size: æ­¥é•¿
        """
        self.goal = np.array(goal)
        self.obstacles = obstacles
        self.k_att = k_att
        self.k_rep = k_rep
        self.rho_0 = rho_0
        self.step_size = step_size
        
    def attractive_force(self, q: np.ndarray) -> np.ndarray:
        """è®¡ç®—å¼•åŠ›"""
        direction = self.goal - q
        dist = np.linalg.norm(direction)
        
        if dist < 1e-6:
            return np.zeros(2)
        
        return self.k_att * direction
    
    def repulsive_force(self, q: np.ndarray) -> np.ndarray:
        """è®¡ç®—æ‰€æœ‰éšœç¢ç‰©çš„æ–¥åŠ›ä¹‹å’Œ"""
        f_rep = np.zeros(2)
        
        for (ox, oy, radius) in self.obstacles:
            obstacle = np.array([ox, oy])
            direction = q - obstacle
            dist = np.linalg.norm(direction)
            
            # å®é™…è·ç¦»å‡å»éšœç¢ç‰©åŠå¾„
            rho = dist - radius
            
            if rho <= self.rho_0 and rho > 1e-6:
                # æ–¥åŠ›å¤§å°
                magnitude = self.k_rep * (1/rho - 1/self.rho_0) * (1/rho**2)
                # æ–¥åŠ›æ–¹å‘
                f_rep += magnitude * direction / dist
        
        return f_rep
    
    def total_force(self, q: np.ndarray) -> np.ndarray:
        """è®¡ç®—åˆåŠ›"""
        return self.attractive_force(q) + self.repulsive_force(q)
    
    def plan(self, start: Tuple[float, float], 
             max_iter: int = 1000,
             goal_threshold: float = 1.0) -> List[np.ndarray]:
        """æ‰§è¡ŒåŠ¿åœºæ³•è§„åˆ’"""
        path = [np.array(start)]
        current = np.array(start)
        
        for _ in range(max_iter):
            # æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡
            if np.linalg.norm(current - self.goal) < goal_threshold:
                path.append(self.goal.copy())
                break
            
            # è®¡ç®—åˆåŠ›
            force = self.total_force(current)
            force_mag = np.linalg.norm(force)
            
            if force_mag < 1e-6:
                # é™·å…¥å±€éƒ¨æå°å€¼
                print("è­¦å‘Šï¼šé™·å…¥å±€éƒ¨æå°å€¼ï¼")
                break
            
            # æ²¿åŠ›çš„æ–¹å‘ç§»åŠ¨
            direction = force / force_mag
            current = current + self.step_size * direction
            path.append(current.copy())
        
        return path
    
    def get_potential_field(self, x_range, y_range, resolution=0.5):
        """ç”ŸæˆåŠ¿åœºå¯è§†åŒ–æ•°æ®"""
        x = np.arange(x_range[0], x_range[1], resolution)
        y = np.arange(y_range[0], y_range[1], resolution)
        X, Y = np.meshgrid(x, y)
        
        U = np.zeros_like(X)
        
        for i in range(X.shape[0]):
            for j in range(X.shape[1]):
                q = np.array([X[i, j], Y[i, j]])
                # è®¡ç®—æ€»åŠ¿èƒ½
                # å¼•åŠ›åŠ¿èƒ½
                u_att = 0.5 * self.k_att * np.linalg.norm(q - self.goal)**2
                
                # æ–¥åŠ›åŠ¿èƒ½
                u_rep = 0
                for (ox, oy, radius) in self.obstacles:
                    dist = np.linalg.norm(q - np.array([ox, oy])) - radius
                    if dist < self.rho_0 and dist > 0:
                        u_rep += 0.5 * self.k_rep * (1/dist - 1/self.rho_0)**2
                
                U[i, j] = u_att + u_rep
        
        return X, Y, U


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    import matplotlib.pyplot as plt
    
    # è®¾ç½®
    goal = (45, 45)
    obstacles = [(20, 20, 5), (30, 30, 5), (25, 35, 4)]
    
    planner = PotentialFieldPlanner(goal, obstacles, k_att=1.0, k_rep=200.0)
    path = planner.plan((5, 5))
    
    # å¯è§†åŒ–
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 7))
    
    # å·¦å›¾ï¼šè·¯å¾„
    for (ox, oy, radius) in obstacles:
        circle = plt.Circle((ox, oy), radius, color='red', alpha=0.6)
        ax1.add_patch(circle)
    
    path_array = np.array(path)
    ax1.plot(path_array[:, 0], path_array[:, 1], 'b-', linewidth=2, label='Path')
    ax1.plot(5, 5, 'go', markersize=15, label='Start')
    ax1.plot(goal[0], goal[1], 'r*', markersize=20, label='Goal')
    ax1.set_xlim(0, 50)
    ax1.set_ylim(0, 50)
    ax1.legend()
    ax1.set_title('Potential Field Path')
    ax1.grid(True)
    
    # å³å›¾ï¼šåŠ¿åœº
    X, Y, U = planner.get_potential_field((0, 50), (0, 50))
    contour = ax2.contourf(X, Y, U, levels=50, cmap='viridis')
    plt.colorbar(contour, ax=ax2, label='Potential')
    ax2.set_title('Potential Field Visualization')
    ax2.grid(True)
    
    plt.tight_layout()
    plt.savefig('potential_field.png')
    plt.show()
```

---

## 6. ç®—æ³•å¯¹æ¯”

### 6.1 æ€§èƒ½å¯¹æ¯”

| ç®—æ³• | å®Œå¤‡æ€§ | æœ€ä¼˜æ€§ | é€‚ç”¨ç©ºé—´ç»´åº¦ | è®¡ç®—å¤æ‚åº¦ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|--------|--------|------------|-----------|------|------|
| **A*** | å®Œå¤‡ | æœ€ä¼˜ | ä½ç»´ï¼ˆç½‘æ ¼ï¼‰ | O(n log n) | æœ€ä¼˜è§£ | éœ€è¦ç¦»æ•£åŒ– |
| **RRT** | æ¦‚ç‡å®Œå¤‡ | éæœ€ä¼˜ | é«˜ç»´ | O(n log n) | ç®€å•é«˜æ•ˆ | è·¯å¾„æ›²æŠ˜ |
| **RRT*** | æ¦‚ç‡å®Œå¤‡ | æ¸è¿›æœ€ä¼˜ | é«˜ç»´ | O(n log n) | æ”¶æ•›æœ€ä¼˜ | è®¡ç®—é‡å¤§ |
| **åŠ¿åœºæ³•** | ä¸å®Œå¤‡ | éæœ€ä¼˜ | ä»»æ„ | O(1) | å®æ—¶æ€§å¥½ | å±€éƒ¨æå° |

### 6.2 é€‰æ‹©æŒ‡å—

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  è·¯å¾„è§„åˆ’ç®—æ³•é€‰æ‹©                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ç©ºé—´ç»´åº¦ â‰¤ 3ï¼Ÿ                                             â”‚
â”‚     â”œâ”€â”€ æ˜¯ï¼šéœ€è¦æœ€ä¼˜è§£ï¼Ÿ                                    â”‚
â”‚     â”‚      â”œâ”€â”€ æ˜¯ â†’ A*                                     â”‚
â”‚     â”‚      â””â”€â”€ å¦ â†’ RRT                                    â”‚
â”‚     â”‚                                                       â”‚
â”‚     â””â”€â”€ å¦ï¼ˆé«˜ç»´ï¼‰ï¼š                                        â”‚
â”‚            éœ€è¦æœ€ä¼˜ï¼Ÿ                                        â”‚
â”‚            â”œâ”€â”€ æ˜¯ â†’ RRT*                                   â”‚
â”‚            â””â”€â”€ å¦ â†’ RRT / PRM                              â”‚
â”‚                                                             â”‚
â”‚  éœ€è¦å®æ—¶è§„åˆ’ï¼Ÿ                                              â”‚
â”‚     â”œâ”€â”€ æ˜¯ â†’ åŠ¿åœºæ³• / æ”¹è¿›RRT                              â”‚
â”‚     â””â”€â”€ å¦ â†’ RRT* / ä¼˜åŒ–åå¤„ç†                             â”‚
â”‚                                                             â”‚
â”‚  åŠ¨æ€ç¯å¢ƒï¼Ÿ                                                  â”‚
â”‚     â”œâ”€â”€ æ˜¯ â†’ D* Lite / åŠ¿åœºæ³•                              â”‚
â”‚     â””â”€â”€ å¦ â†’ é™æ€è§„åˆ’ç®—æ³•                                   â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.3 å®é™…åº”ç”¨æ¨è

| åº”ç”¨åœºæ™¯ | æ¨èç®—æ³• | åŸå›  |
|---------|---------|------|
| ç§»åŠ¨æœºå™¨äººå¯¼èˆª | A* + è·¯å¾„å¹³æ»‘ | ä½ç»´ç©ºé—´ï¼Œéœ€è¦æœ€ä¼˜ |
| æœºæ¢°è‡‚è¿åŠ¨è§„åˆ’ | RRT* + MoveIt | é«˜ç»´æ„å‹ç©ºé—´ |
| æ— äººæœºè·¯å¾„è§„åˆ’ | RRT / A* | éœ€è¦è€ƒè™‘3Dç©ºé—´ |
| è‡ªåŠ¨é©¾é©¶ | Hybrid A* | éœ€è¦è€ƒè™‘è½¦è¾†è¿åŠ¨å­¦ |
| å®æ—¶é¿éšœ | åŠ¿åœºæ³• / MPC | ä½å»¶è¿Ÿè¦æ±‚ |

---

## å»¶ä¼¸é˜…è¯»

### è®ºæ–‡
- "Rapidly-Exploring Random Trees" - LaValle (1998)
- "Sampling-based Algorithms for Optimal Motion Planning" - Karaman & Frazzoli (2011)
- "Optimal Path Planning Graph Algorithms" - A* åŸå§‹è®ºæ–‡

### å¼€æºåº“
- **OMPL**: Open Motion Planning Library
- **MoveIt**: ROSè¿åŠ¨è§„åˆ’æ¡†æ¶
- **PYROBOCOP**: Pythonæœºå™¨äººæ§åˆ¶ä¸ä¼˜åŒ–

---

*æœ¬ç« èŠ‚æŒç»­æ›´æ–°ä¸­...*
