# é¿éšœç®—æ³•

é¿éšœï¼ˆObstacle Avoidanceï¼‰æ˜¯æœºå™¨äººå¯¼èˆªä¸­çš„æ ¸å¿ƒé—®é¢˜ï¼Œç¡®ä¿æœºå™¨äººèƒ½å¤Ÿå®‰å…¨åœ°ç»•è¿‡éšœç¢ç‰©åˆ°è¾¾ç›®æ ‡ã€‚

## ğŸ“‹ ç›®å½•

- [1. æ¦‚è¿°](#1-æ¦‚è¿°)
- [2. åŠ¨æ€çª—å£æ³•ï¼ˆDWAï¼‰](#2-åŠ¨æ€çª—å£æ³•dwa)
- [3. äººå·¥åŠ¿åœºæ³•](#3-äººå·¥åŠ¿åœºæ³•)
- [4. æ¨¡å‹é¢„æµ‹æ§åˆ¶ï¼ˆMPCï¼‰](#4-æ¨¡å‹é¢„æµ‹æ§åˆ¶mpc)
- [5. æ·±åº¦å­¦ä¹ é¿éšœ](#5-æ·±åº¦å­¦ä¹ é¿éšœ)
- [6. ç®—æ³•å¯¹æ¯”](#6-ç®—æ³•å¯¹æ¯”)

---

## 1. æ¦‚è¿°

### 1.1 é¿éšœé—®é¢˜å®šä¹‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    é¿éšœé—®é¢˜                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ç›®æ ‡ï¼šåœ¨ä¿è¯å®‰å…¨çš„å‰æä¸‹ï¼Œå‘ç›®æ ‡å‰è¿›                        â”‚
â”‚                                                             â”‚
â”‚  è¾“å…¥ï¼š                                                      â”‚
â”‚  â€¢ æœºå™¨äººå½“å‰çŠ¶æ€ï¼ˆä½ç½®ã€é€Ÿåº¦ï¼‰                              â”‚
â”‚  â€¢ ä¼ æ„Ÿå™¨æ„ŸçŸ¥çš„éšœç¢ç‰©ä¿¡æ¯                                    â”‚
â”‚  â€¢ ç›®æ ‡ä½ç½®                                                 â”‚
â”‚                                                             â”‚
â”‚  è¾“å‡ºï¼š                                                      â”‚
â”‚  â€¢ å®‰å…¨çš„é€Ÿåº¦æŒ‡ä»¤ï¼ˆv, Ï‰ï¼‰æˆ–åŠ é€Ÿåº¦                           â”‚
â”‚                                                             â”‚
â”‚  çº¦æŸï¼š                                                      â”‚
â”‚  â€¢ è¿åŠ¨å­¦çº¦æŸï¼ˆæœ€å¤§é€Ÿåº¦ã€åŠ é€Ÿåº¦ï¼‰                            â”‚
â”‚  â€¢ åŠ¨åŠ›å­¦çº¦æŸ                                               â”‚
â”‚  â€¢ å®‰å…¨è·ç¦»çº¦æŸ                                             â”‚
â”‚                                                             â”‚
â”‚  æŒ‘æˆ˜ï¼š                                                      â”‚
â”‚  â€¢ ä¼ æ„Ÿå™¨å™ªå£°å’Œä¸ç¡®å®šæ€§                                      â”‚
â”‚  â€¢ åŠ¨æ€éšœç¢ç‰©                                               â”‚
â”‚  â€¢ å®æ—¶æ€§è¦æ±‚                                               â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 é¿éšœæ–¹æ³•åˆ†ç±»

| æ–¹æ³•ç±»å‹ | ä»£è¡¨ç®—æ³• | ç‰¹ç‚¹ |
|---------|---------|------|
| **ååº”å¼** | åŠ¿åœºæ³•ã€VFH | é€Ÿåº¦å¿«ï¼Œå±€éƒ¨æœ€ä¼˜ |
| **é¢„æµ‹å¼** | DWAã€MPC | è€ƒè™‘è¿åŠ¨æ¨¡å‹ |
| **å­¦ä¹ å¼** | ç¥ç»ç½‘ç»œã€RL | æ³›åŒ–èƒ½åŠ›å¼º |

---

## 2. åŠ¨æ€çª—å£æ³•ï¼ˆDWAï¼‰

### 2.1 ç®—æ³•åŸç†

DWAï¼ˆDynamic Window Approachï¼‰é€šè¿‡åœ¨é€Ÿåº¦ç©ºé—´ä¸­æœç´¢æœ€ä¼˜é€Ÿåº¦å‘½ä»¤æ¥å®ç°é¿éšœã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    DWA æ ¸å¿ƒæ€æƒ³                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. ç¡®å®šæœç´¢ç©ºé—´ï¼ˆåŠ¨æ€çª—å£ï¼‰ï¼š                               â”‚
â”‚     â€¢ è€ƒè™‘æœ€å¤§é€Ÿåº¦/åŠ é€Ÿåº¦çº¦æŸ                               â”‚
â”‚     â€¢ è€ƒè™‘å½“å‰é€Ÿåº¦                                          â”‚
â”‚     â€¢ åªè€ƒè™‘ä¸€ä¸ªå‘¨æœŸå†…å¯è¾¾çš„é€Ÿåº¦                            â”‚
â”‚                                                             â”‚
â”‚  2. å¯¹æ¯ä¸ªå€™é€‰é€Ÿåº¦è¿›è¡Œè¯„åˆ†ï¼š                                 â”‚
â”‚     G(v, Ï‰) = Ïƒ(Î±*heading + Î²*dist + Î³*velocity)          â”‚
â”‚                                                             â”‚
â”‚     â€¢ headingï¼šæœå‘ç›®æ ‡çš„ç¨‹åº¦                               â”‚
â”‚     â€¢ distï¼šåˆ°æœ€è¿‘éšœç¢ç‰©çš„è·ç¦»                              â”‚
â”‚     â€¢ velocityï¼šå‰è¿›é€Ÿåº¦ï¼ˆè¶Šå¿«è¶Šå¥½ï¼‰                        â”‚
â”‚                                                             â”‚
â”‚  3. é€‰æ‹©è¯„åˆ†æœ€é«˜çš„é€Ÿåº¦æ‰§è¡Œ                                   â”‚
â”‚                                                             â”‚
â”‚  4. å¾ªç¯æ‰§è¡Œ                                                â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 åŠ¨æ€çª—å£è®¡ç®—

```
åŠ¨æ€çª—å£ Vs âŠ‚ V å®šä¹‰ä¸ºå¯è¾¾é€Ÿåº¦é›†åˆï¼š

Vs = {(v, Ï‰) | v âˆˆ [v_curr - a_dec*Î”t, v_curr + a_acc*Î”t]
           âˆ§ Ï‰ âˆˆ [Ï‰_curr - Î±_dec*Î”t, Ï‰_curr + Î±_acc*Î”t]
           âˆ§ v âˆˆ [0, v_max] âˆ§ Ï‰ âˆˆ [-Ï‰_max, Ï‰_max]}

å…¶ä¸­ï¼š
â€¢ v_curr, Ï‰_currï¼šå½“å‰çº¿é€Ÿåº¦å’Œè§’é€Ÿåº¦
â€¢ a_acc, a_decï¼šçº¿åŠ é€Ÿåº¦å’Œå‡é€Ÿåº¦é™åˆ¶
â€¢ Î±_acc, Î±_decï¼šè§’åŠ é€Ÿåº¦é™åˆ¶
â€¢ Î”tï¼šæ—¶é—´æ­¥é•¿
```

### 2.3 è½¨è¿¹é¢„æµ‹

å¯¹äºç»™å®šçš„é€Ÿåº¦ (v, Ï‰)ï¼Œé¢„æµ‹æœªæ¥è½¨è¿¹ï¼š

```
å‡è®¾åŒ€é€Ÿåœ†å‘¨è¿åŠ¨ï¼š

x(t+Î”t) = x(t) + v * cos(Î¸) * Î”t
y(t+Î”t) = y(t) + v * sin(Î¸) * Î”t
Î¸(t+Î”t) = Î¸(t) + Ï‰ * Î”t
```

### 2.4 Pythonå®ç°

```python
import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, List, Optional

class DynamicWindowApproach:
    """åŠ¨æ€çª—å£æ³•é¿éšœç®—æ³•"""
    
    def __init__(self, 
                 max_speed: float = 1.0,
                 min_speed: float = 0.0,
                 max_yaw_rate: float = 40.0 * np.pi / 180.0,
                 max_accel: float = 0.5,
                 max_delta_yaw_rate: float = 40.0 * np.pi / 180.0,
                 dt: float = 0.1,
                 predict_time: float = 3.0,
                 heading_cost_gain: float = 0.15,
                 speed_cost_gain: float = 1.0,
                 obstacle_cost_gain: float = 1.0,
                 robot_radius: float = 0.3):
        """
        åˆå§‹åŒ–DWAå‚æ•°
        
        Args:
            max_speed: æœ€å¤§çº¿é€Ÿåº¦ (m/s)
            min_speed: æœ€å°çº¿é€Ÿåº¦ (m/s)
            max_yaw_rate: æœ€å¤§è§’é€Ÿåº¦ (rad/s)
            max_accel: æœ€å¤§åŠ é€Ÿåº¦ (m/sÂ²)
            max_delta_yaw_rate: æœ€å¤§è§’åŠ é€Ÿåº¦ (rad/sÂ²)
            dt: æ—¶é—´æ­¥é•¿ (s)
            predict_time: è½¨è¿¹é¢„æµ‹æ—¶é—´ (s)
            heading_cost_gain: æœå‘ä»£ä»·æƒé‡
            speed_cost_gain: é€Ÿåº¦ä»£ä»·æƒé‡
            obstacle_cost_gain: éšœç¢ç‰©ä»£ä»·æƒé‡
            robot_radius: æœºå™¨äººåŠå¾„ (m)
        """
        self.max_speed = max_speed
        self.min_speed = min_speed
        self.max_yaw_rate = max_yaw_rate
        self.max_accel = max_accel
        self.max_delta_yaw_rate = max_delta_yaw_rate
        self.dt = dt
        self.predict_time = predict_time
        self.heading_cost_gain = heading_cost_gain
        self.speed_cost_gain = speed_cost_gain
        self.obstacle_cost_gain = obstacle_cost_gain
        self.robot_radius = robot_radius
        
    def calc_dynamic_window(self, v: float, Ï‰: float) -> Tuple[float, float, float, float]:
        """
        è®¡ç®—åŠ¨æ€çª—å£
        
        Args:
            v: å½“å‰çº¿é€Ÿåº¦
            Ï‰: å½“å‰è§’é€Ÿåº¦
        
        Returns:
            (v_min, v_max, Ï‰_min, Ï‰_max)
        """
        # è€ƒè™‘åŠ é€Ÿåº¦é™åˆ¶
        Vs = [self.min_speed, self.max_speed, -self.max_yaw_rate, self.max_yaw_rate]
        
        # è€ƒè™‘åŠ¨æ€çº¦æŸ
        Vd = [v - self.max_accel * self.dt,
              v + self.max_accel * self.dt,
              Ï‰ - self.max_delta_yaw_rate * self.dt,
              Ï‰ + self.max_delta_yaw_rate * self.dt]
        
        # æœ€ç»ˆçª—å£
        v_min = max(Vs[0], Vd[0])
        v_max = min(Vs[1], Vd[1])
        Ï‰_min = max(Vs[2], Vd[2])
        Ï‰_max = min(Vs[3], Vd[3])
        
        return v_min, v_max, Ï‰_min, Ï‰_max
    
    def predict_trajectory(self, x: float, y: float, Î¸: float, 
                          v: float, Ï‰: float) -> np.ndarray:
        """
        é¢„æµ‹è½¨è¿¹
        
        Args:
            x, y, Î¸: å½“å‰ä½å§¿
            v, Ï‰: é€Ÿåº¦å‘½ä»¤
        
        Returns:
            è½¨è¿¹æ•°ç»„ï¼Œshapeä¸º (N, 3) - (x, y, Î¸)
        """
        trajectory = np.array([[x, y, Î¸]])
        time = 0
        
        while time <= self.predict_time:
            # è¿åŠ¨å­¦æ¨¡å‹
            x += v * np.cos(Î¸) * self.dt
            y += v * np.sin(Î¸) * self.dt
            Î¸ += Ï‰ * self.dt
            
            trajectory = np.vstack([trajectory, [x, y, Î¸]])
            time += self.dt
        
        return trajectory
    
    def calc_heading_cost(self, trajectory: np.ndarray, goal: np.ndarray) -> float:
        """è®¡ç®—æœå‘ä»£ä»·ï¼ˆè§’åº¦è¶Šå°è¶Šå¥½ï¼‰"""
        dx = goal[0] - trajectory[-1, 0]
        dy = goal[1] - trajectory[-1, 1]
        angle_to_goal = np.arctan2(dy, dx)
        
        angle_diff = abs(angle_to_goal - trajectory[-1, 2])
        angle_diff = (angle_diff + np.pi) % (2 * np.pi) - np.pi
        
        return abs(angle_diff)
    
    def calc_obstacle_cost(self, trajectory: np.ndarray, obstacles: np.ndarray) -> float:
        """
        è®¡ç®—éšœç¢ç‰©ä»£ä»·
        
        Args:
            trajectory: é¢„æµ‹è½¨è¿¹
            obstacles: éšœç¢ç‰©ä½ç½®æ•°ç»„ï¼Œshapeä¸º (N, 2)
        
        Returns:
            ä»£ä»·ï¼ˆè·ç¦»è¶Šè¿‘ä»£ä»·è¶Šé«˜ï¼‰
        """
        min_dist = float('inf')
        
        for point in trajectory:
            for obs in obstacles:
                dist = np.sqrt((point[0] - obs[0])**2 + (point[1] - obs[1])**2)
                if dist < self.robot_radius:
                    return float('inf')  # ç¢°æ’
                
                if dist < min_dist:
                    min_dist = dist
        
        # è·ç¦»è¶Šè¿‘ä»£ä»·è¶Šé«˜
        return 1.0 / min_dist if min_dist > 0 else float('inf')
    
    def calc_speed_cost(self, v: float) -> float:
        """è®¡ç®—é€Ÿåº¦ä»£ä»·ï¼ˆé€Ÿåº¦è¶Šå¿«è¶Šå¥½ï¼‰"""
        return self.max_speed - v
    
    def calc_total_cost(self, trajectory: np.ndarray, v: float, 
                       goal: np.ndarray, obstacles: np.ndarray) -> float:
        """è®¡ç®—æ€»ä»£ä»·"""
        heading_cost = self.calc_heading_cost(trajectory, goal)
        obstacle_cost = self.calc_obstacle_cost(trajectory, obstacles)
        speed_cost = self.calc_speed_cost(v)
        
        return (self.heading_cost_gain * heading_cost + 
                self.obstacle_cost_gain * obstacle_cost + 
                self.speed_cost_gain * speed_cost)
    
    def plan(self, state: np.ndarray, goal: np.ndarray, 
            obstacles: np.ndarray) -> Tuple[float, float, np.ndarray]:
        """
        æ‰§è¡ŒDWAè§„åˆ’
        
        Args:
            state: å½“å‰çŠ¶æ€ [x, y, Î¸, v, Ï‰]
            goal: ç›®æ ‡ä½ç½® [x, y]
            obstacles: éšœç¢ç‰©æ•°ç»„ (N, 2)
        
        Returns:
            (v_cmd, Ï‰_cmd, best_trajectory)
        """
        x, y, Î¸, v, Ï‰ = state
        
        # è®¡ç®—åŠ¨æ€çª—å£
        v_min, v_max, Ï‰_min, Ï‰_max = self.calc_dynamic_window(v, Ï‰)
        
        # æœç´¢æœ€ä¼˜é€Ÿåº¦
        min_cost = float('inf')
        best_v, best_Ï‰ = 0.0, 0.0
        best_trajectory = None
        
        # é€Ÿåº¦é‡‡æ ·
        v_samples = np.linspace(v_min, v_max, 10)
        Ï‰_samples = np.linspace(Ï‰_min, Ï‰_max, 20)
        
        for v_sample in v_samples:
            for Ï‰_sample in Ï‰_samples:
                # é¢„æµ‹è½¨è¿¹
                trajectory = self.predict_trajectory(x, y, Î¸, v_sample, Ï‰_sample)
                
                # è®¡ç®—ä»£ä»·
                cost = self.calc_total_cost(trajectory, v_sample, goal, obstacles)
                
                if cost < min_cost:
                    min_cost = cost
                    best_v = v_sample
                    best_Ï‰ = Ï‰_sample
                    best_trajectory = trajectory
        
        return best_v, best_Ï‰, best_trajectory


# ============ ä½¿ç”¨ç¤ºä¾‹ ============
def simulate_dwa():
    """DWAä»¿çœŸç¤ºä¾‹"""
    # åˆå§‹åŒ–
    dwa = DynamicWindowApproach(
        max_speed=1.0,
        max_yaw_rate=np.pi/3,
        robot_radius=0.3
    )
    
    # æœºå™¨äººåˆå§‹çŠ¶æ€ [x, y, Î¸, v, Ï‰]
    state = np.array([0.0, 0.0, 0.0, 0.0, 0.0])
    
    # ç›®æ ‡
    goal = np.array([8.0, 8.0])
    
    # éšœç¢ç‰©
    obstacles = np.array([
        [3.0, 3.0],
        [4.0, 5.0],
        [5.0, 4.0],
        [6.0, 6.0],
        [2.0, 5.0],
        [7.0, 3.0],
    ])
    
    # ä»¿çœŸ
    trajectory = [state[:3].copy()]
    
    for _ in range(500):
        # è§„åˆ’
        v_cmd, Ï‰_cmd, pred_traj = dwa.plan(state, goal, obstacles)
        
        # æ›´æ–°çŠ¶æ€
        state[0] += v_cmd * np.cos(state[2]) * dwa.dt
        state[1] += v_cmd * np.sin(state[2]) * dwa.dt
        state[2] += Ï‰_cmd * dwa.dt
        state[3] = v_cmd
        state[4] = Ï‰_cmd
        
        trajectory.append(state[:3].copy())
        
        # æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡
        if np.sqrt((state[0] - goal[0])**2 + (state[1] - goal[1])**2) < 0.3:
            print("åˆ°è¾¾ç›®æ ‡ï¼")
            break
    
    # å¯è§†åŒ–
    plt.figure(figsize=(10, 10))
    
    # ç»˜åˆ¶éšœç¢ç‰©
    for obs in obstacles:
        circle = plt.Circle(obs, 0.3, color='red', alpha=0.6)
        plt.gca().add_patch(circle)
    
    # ç»˜åˆ¶è½¨è¿¹
    traj = np.array(trajectory)
    plt.plot(traj[:, 0], traj[:, 1], 'b-', linewidth=2, label='Robot Path')
    
    # ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
    plt.plot(0, 0, 'go', markersize=15, label='Start')
    plt.plot(goal[0], goal[1], 'r*', markersize=20, label='Goal')
    
    plt.xlim(-1, 10)
    plt.ylim(-1, 10)
    plt.legend()
    plt.grid(True)
    plt.title('DWA Obstacle Avoidance')
    plt.xlabel('X (m)')
    plt.ylabel('Y (m)')
    plt.savefig('dwa_simulation.png')
    plt.show()

if __name__ == "__main__":
    simulate_dwa()
```

---

## 3. äººå·¥åŠ¿åœºæ³•

### 3.1 ç®—æ³•åŸç†ï¼ˆç”¨äºé¿éšœï¼‰

äººå·¥åŠ¿åœºæ³•å°†ç¯å¢ƒå»ºæ¨¡ä¸ºåŠ¿åœºï¼š
- ç›®æ ‡ç‚¹äº§ç”Ÿå¼•åŠ›åœº
- éšœç¢ç‰©äº§ç”Ÿæ–¥åŠ›åœº

è¯¦è§ [è·¯å¾„è§„åˆ’ - åŠ¿åœºæ³•](./è·¯å¾„è§„åˆ’.md#5-åŠ¿åœºæ³•)

### 3.2 æ”¹è¿›æ–¹æ³•

ä¸ºè§£å†³å±€éƒ¨æå°å€¼é—®é¢˜ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                åŠ¿åœºæ³•æ”¹è¿›ç­–ç•¥                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. è™šæ‹Ÿç›®æ ‡ç‚¹                                              â”‚
â”‚     å½“æ£€æµ‹åˆ°å±€éƒ¨æå°å€¼æ—¶ï¼Œä¸´æ—¶æ·»åŠ è™šæ‹Ÿç›®æ ‡                  â”‚
â”‚                                                             â”‚
â”‚  2. éšæœºæ‰°åŠ¨                                                â”‚
â”‚     åœ¨åˆåŠ›æ–¹å‘æ·»åŠ éšæœºæ‰°åŠ¨è·³å‡ºå±€éƒ¨æå°                      â”‚
â”‚                                                             â”‚
â”‚  3. æ²¿å¢™è¡Œèµ°                                                â”‚
â”‚     å½“é™·å…¥æ—¶æ²¿éšœç¢ç‰©è¾¹ç•Œç§»åŠ¨                                â”‚
â”‚                                                             â”‚
â”‚  4. æ”¹è¿›åŠ¿åœºå‡½æ•°                                            â”‚
â”‚     ä½¿ç”¨æ—‹è½¬åŠ¿åœºæˆ–å…¶ä»–å½¢å¼çš„åŠ¿åœº                            â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 å¸¦é¿éšœçš„åŠ¿åœºæ³•

```python
class ImprovedPotentialField:
    """æ”¹è¿›çš„åŠ¿åœºæ³•é¿éšœ"""
    
    def __init__(self, k_att=1.0, k_rep=100.0, rho_0=2.0):
        self.k_att = k_att
        self.k_rep = k_rep
        self.rho_0 = rho_0
        self.stuck_counter = 0
        self.prev_position = None
        
    def detect_local_minimum(self, position: np.ndarray, force: np.ndarray) -> bool:
        """æ£€æµ‹æ˜¯å¦é™·å…¥å±€éƒ¨æå°å€¼"""
        if self.prev_position is not None:
            # æ£€æŸ¥ä½ç½®å˜åŒ–å¾ˆå°ä½†åŠ›ä¹Ÿå¾ˆå°
            pos_change = np.linalg.norm(position - self.prev_position)
            force_mag = np.linalg.norm(force)
            
            if pos_change < 0.01 and force_mag < 0.1:
                self.stuck_counter += 1
            else:
                self.stuck_counter = 0
        
        self.prev_position = position.copy()
        return self.stuck_counter > 10
    
    def escape_local_minimum(self, position: np.ndarray, obstacles: np.ndarray) -> np.ndarray:
        """é€ƒç¦»å±€éƒ¨æå°å€¼ - æ²¿å¢™è¡Œèµ°"""
        # æ‰¾åˆ°æœ€è¿‘çš„éšœç¢ç‰©
        min_dist = float('inf')
        nearest_obs = None
        
        for obs in obstacles:
            dist = np.linalg.norm(position - obs)
            if dist < min_dist:
                min_dist = dist
                nearest_obs = obs
        
        if nearest_obs is not None:
            # æ²¿éšœç¢ç‰©åˆ‡å‘ç§»åŠ¨
            direction = position - nearest_obs
            tangent = np.array([-direction[1], direction[0]])
            return tangent / np.linalg.norm(tangent)
        
        return np.zeros(2)
    
    def compute_force(self, position: np.ndarray, goal: np.ndarray, 
                     obstacles: np.ndarray) -> np.ndarray:
        """è®¡ç®—æ”¹è¿›çš„åŠ¿åœºåŠ›"""
        # å¼•åŠ›
        f_att = self.k_att * (goal - position)
        
        # æ–¥åŠ›
        f_rep = np.zeros(2)
        for obs in obstacles:
            direction = position - obs
            dist = np.linalg.norm(direction)
            
            if dist < self.rho_0 and dist > 0:
                magnitude = self.k_rep * (1/dist - 1/self.rho_0) / (dist**2)
                f_rep += magnitude * direction / dist
        
        total_force = f_att + f_rep
        
        # æ£€æµ‹å±€éƒ¨æå°å€¼
        if self.detect_local_minimum(position, total_force):
            total_force = self.escape_local_minimum(position, obstacles)
            self.stuck_counter = 0
        
        return total_force
```

---

## 4. æ¨¡å‹é¢„æµ‹æ§åˆ¶ï¼ˆMPCï¼‰

### 4.1 MPCåŸç†

MPCï¼ˆModel Predictive Controlï¼‰é€šè¿‡æ»šåŠ¨ä¼˜åŒ–å®ç°é¿éšœã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MPC é¿éšœæ¡†æ¶                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ä¼˜åŒ–é—®é¢˜ï¼š                                                  â”‚
â”‚                                                             â”‚
â”‚  min  Î£ (||x_k - x_ref||Â²_Q + ||u_k||Â²_R)                  â”‚
â”‚  u                                                            â”‚
â”‚                                                             â”‚
â”‚  çº¦æŸï¼š                                                      â”‚
â”‚  â€¢ x_{k+1} = f(x_k, u_k)  (åŠ¨åŠ›å­¦æ¨¡å‹)                      â”‚
â”‚  â€¢ ||p_k - p_obs|| â‰¥ r_safe  (å®‰å…¨è·ç¦»)                    â”‚
â”‚  â€¢ u_min â‰¤ u_k â‰¤ u_max    (æ§åˆ¶è¾“å…¥é™åˆ¶)                   â”‚
â”‚  â€¢ x_min â‰¤ x_k â‰¤ x_max    (çŠ¶æ€é™åˆ¶)                       â”‚
â”‚                                                             â”‚
â”‚  æ­¥éª¤ï¼š                                                      â”‚
â”‚  1. åœ¨é¢„æµ‹æ—¶åŸŸå†…ä¼˜åŒ–æ§åˆ¶åºåˆ—                                 â”‚
â”‚  2. æ‰§è¡Œç¬¬ä¸€ä¸ªæ§åˆ¶è¾“å…¥                                       â”‚
â”‚  3. æ›´æ–°çŠ¶æ€ï¼Œé‡å¤æ­¥éª¤1                                      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Pythonå®ç°ï¼ˆç®€åŒ–ç‰ˆï¼‰

```python
from scipy.optimize import minimize
import numpy as np

class MPCObstacleAvoidance:
    """MPCé¿éšœæ§åˆ¶å™¨"""
    
    def __init__(self, 
                 horizon: int = 10,
                 dt: float = 0.1,
                 v_max: float = 1.0,
                 Ï‰_max: float = np.pi/3,
                 Q: np.ndarray = None,
                 R: np.ndarray = None):
        """
        Args:
            horizon: é¢„æµ‹æ—¶åŸŸ
            dt: æ—¶é—´æ­¥é•¿
            v_max: æœ€å¤§çº¿é€Ÿåº¦
            Ï‰_max: æœ€å¤§è§’é€Ÿåº¦
            Q: çŠ¶æ€ä»£ä»·çŸ©é˜µ
            R: æ§åˆ¶ä»£ä»·çŸ©é˜µ
        """
        self.horizon = horizon
        self.dt = dt
        self.v_max = v_max
        self.Ï‰_max = Ï‰_max
        
        # é»˜è®¤ä»£ä»·çŸ©é˜µ
        self.Q = Q if Q is not None else np.diag([1.0, 1.0, 0.1])
        self.R = R if R is not None else np.diag([0.1, 0.1])
        
    def motion_model(self, state: np.ndarray, u: np.ndarray) -> np.ndarray:
        """è¿åŠ¨å­¦æ¨¡å‹"""
        x, y, Î¸ = state
        v, Ï‰ = u
        
        x_new = x + v * np.cos(Î¸) * self.dt
        y_new = y + v * np.sin(Î¸) * self.dt
        Î¸_new = Î¸ + Ï‰ * self.dt
        
        return np.array([x_new, y_new, Î¸_new])
    
    def cost_function(self, u_seq: np.ndarray, 
                     state: np.ndarray, 
                     goal: np.ndarray,
                     obstacles: np.ndarray,
                     robot_radius: float = 0.3) -> float:
        """
        ä»£ä»·å‡½æ•°
        
        Args:
            u_seq: æ§åˆ¶è¾“å…¥åºåˆ— [v1, Ï‰1, v2, Ï‰2, ...]
            state: å½“å‰çŠ¶æ€
            goal: ç›®æ ‡çŠ¶æ€
            obstacles: éšœç¢ç‰©åˆ—è¡¨
            robot_radius: æœºå™¨äººåŠå¾„
        """
        cost = 0.0
        x = state.copy()
        
        for k in range(self.horizon):
            # è·å–å½“å‰æ§åˆ¶è¾“å…¥
            u = u_seq[2*k:2*k+2]
            
            # é¢„æµ‹ä¸‹ä¸€ä¸ªçŠ¶æ€
            x = self.motion_model(x, u)
            
            # çŠ¶æ€ä»£ä»·ï¼ˆè·Ÿè¸ªç›®æ ‡ï¼‰
            state_error = x[:2] - goal[:2]  # åªè€ƒè™‘ä½ç½®
            cost += state_error @ self.Q[:2, :2] @ state_error
            
            # æ§åˆ¶ä»£ä»·
            cost += u @ self.R @ u
            
            # éšœç¢ç‰©ä»£ä»·
            for obs in obstacles:
                dist = np.sqrt((x[0] - obs[0])**2 + (x[1] - obs[1])**2)
                if dist < robot_radius:
                    cost += 1e6  # ç¢°æ’æƒ©ç½š
                elif dist < robot_radius + 0.5:
                    # è½¯çº¦æŸ
                    cost += 100.0 / (dist - robot_radius + 0.01)
        
        return cost
    
    def plan(self, 
             state: np.ndarray, 
             goal: np.ndarray, 
             obstacles: np.ndarray) -> Tuple[float, float]:
        """
        MPCè§„åˆ’
        
        Returns:
            (v_cmd, Ï‰_cmd)
        """
        # åˆå§‹çŒœæµ‹
        u0 = np.zeros(2 * self.horizon)
        
        # æ§åˆ¶è¾“å…¥è¾¹ç•Œ
        bounds = []
        for _ in range(self.horizon):
            bounds.extend([
                (0, self.v_max),           # v
                (-self.Ï‰_max, self.Ï‰_max)  # Ï‰
            ])
        
        # ä¼˜åŒ–
        result = minimize(
            self.cost_function,
            u0,
            args=(state, goal, obstacles),
            method='SLSQP',
            bounds=bounds,
            options={'maxiter': 50}
        )
        
        # è¿”å›ç¬¬ä¸€ä¸ªæ§åˆ¶è¾“å…¥
        v_cmd = result.x[0]
        Ï‰_cmd = result.x[1]
        
        return v_cmd, Ï‰_cmd


# MPCä»¿çœŸ
def simulate_mpc():
    """MPCé¿éšœä»¿çœŸ"""
    mpc = MPCObstacleAvoidance(horizon=15, dt=0.1)
    
    state = np.array([0.0, 0.0, 0.0])
    goal = np.array([8.0, 8.0, 0.0])
    obstacles = np.array([[3.0, 3.0], [5.0, 4.0], [6.0, 6.0]])
    
    trajectory = [state.copy()]
    
    for _ in range(200):
        v, Ï‰ = mpc.plan(state, goal, obstacles)
        
        # æ›´æ–°çŠ¶æ€
        state = mpc.motion_model(state, [v, Ï‰])
        trajectory.append(state.copy())
        
        if np.linalg.norm(state[:2] - goal[:2]) < 0.3:
            break
    
    return np.array(trajectory)

if __name__ == "__main__":
    traj = simulate_mpc()
    print(f"è½¨è¿¹é•¿åº¦: {len(traj)}")
```

---

## 5. æ·±åº¦å­¦ä¹ é¿éšœ

### 5.1 ç«¯åˆ°ç«¯å­¦ä¹ 

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æ·±åº¦å­¦ä¹ é¿éšœæ¶æ„                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  è¾“å…¥                        ç¥ç»ç½‘ç»œ           è¾“å‡º        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ æ¿€å…‰é›·è¾¾ â”‚â”€â”€â”          â”‚  CNN +  â”‚       â”‚  v_cmd  â”‚   â”‚
â”‚  â”‚  æ‰«æ   â”‚  â”œâ”€â”€â–¶ æ‹¼æ¥ â”€â”€â–¶â”‚  LSTM   â”‚â”€â”€â–¶ MLPâ”€â”€â–¶â”‚         â”‚   â”‚
â”‚  â”‚ ç›®æ ‡æ–¹å‘â”‚â”€â”€â”˜          â”‚         â”‚       â”‚  Ï‰_cmd  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                             â”‚
â”‚  è®­ç»ƒæ–¹å¼ï¼š                                                  â”‚
â”‚  1. ç›‘ç£å­¦ä¹ ï¼šä¸“å®¶æ¼”ç¤º                                      â”‚
â”‚  2. å¼ºåŒ–å­¦ä¹ ï¼šå¥–åŠ±é©±åŠ¨                                      â”‚
â”‚  3. æ¨¡ä»¿å­¦ä¹ ï¼šè¡Œä¸ºå…‹éš†                                      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 ç®€å•ç½‘ç»œç¤ºä¾‹

```python
import torch
import torch.nn as nn

class ObstacleAvoidanceNet(nn.Module):
    """åŸºäºæ¿€å…‰é›·è¾¾çš„é¿éšœç½‘ç»œ"""
    
    def __init__(self, lidar_points: int = 360, hidden_size: int = 128):
        super().__init__()
        
        # æ¿€å…‰é›·è¾¾å¤„ç†åˆ†æ”¯
        self.lidar_encoder = nn.Sequential(
            nn.Linear(lidar_points, 256),
            nn.ReLU(),
            nn.Linear(256, 128),
            nn.ReLU()
        )
        
        # ç›®æ ‡æ–¹å‘å¤„ç†
        self.goal_encoder = nn.Sequential(
            nn.Linear(2, 32),  # ç›®æ ‡ç›¸å¯¹ä½ç½® (dx, dy)
            nn.ReLU()
        )
        
        # èåˆå±‚
        self.fusion = nn.Sequential(
            nn.Linear(128 + 32, hidden_size),
            nn.ReLU(),
            nn.Linear(hidden_size, 64),
            nn.ReLU()
        )
        
        # è¾“å‡ºå±‚
        self.output = nn.Sequential(
            nn.Linear(64, 2),  # (v, Ï‰)
            nn.Tanh()
        )
        
    def forward(self, lidar_scan: torch.Tensor, goal_relative: torch.Tensor):
        """
        Args:
            lidar_scan: æ¿€å…‰é›·è¾¾æ•°æ® [batch, 360]
            goal_relative: ç›®æ ‡ç›¸å¯¹ä½ç½® [batch, 2]
        
        Returns:
            v, Ï‰: é€Ÿåº¦å‘½ä»¤ [batch, 2]
        """
        lidar_feat = self.lidar_encoder(lidar_scan)
        goal_feat = self.goal_encoder(goal_relative)
        
        fused = torch.cat([lidar_feat, goal_feat], dim=-1)
        hidden = self.fusion(fused)
        output = self.output(hidden)
        
        # ç¼©æ”¾åˆ°å®é™…é€Ÿåº¦èŒƒå›´
        v = (output[:, 0] + 1) / 2 * 1.0  # [0, 1] m/s
        Ï‰ = output[:, 1] * np.pi / 3       # [-Ï€/3, Ï€/3] rad/s
        
        return torch.stack([v, Ï‰], dim=-1)


# è®­ç»ƒç¤ºä¾‹
def train_obstacle_avoidance():
    """è®­ç»ƒé¿éšœç½‘ç»œï¼ˆä¼ªä»£ç ï¼‰"""
    model = ObstacleAvoidanceNet()
    optimizer = torch.optim.Adam(model.parameters(), lr=1e-3)
    criterion = nn.MSELoss()
    
    # å‡è®¾æœ‰è®­ç»ƒæ•°æ®
    # lidar_data: [N, 360]
    # goal_data: [N, 2]
    # expert_actions: [N, 2]
    
    for epoch in range(100):
        # å‰å‘ä¼ æ’­
        pred_actions = model(lidar_data, goal_data)
        
        # è®¡ç®—æŸå¤±
        loss = criterion(pred_actions, expert_actions)
        
        # åå‘ä¼ æ’­
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()
        
        print(f"Epoch {epoch}, Loss: {loss.item():.4f}")
```

---

## 6. ç®—æ³•å¯¹æ¯”

### 6.1 æ€§èƒ½å¯¹æ¯”è¡¨

| ç®—æ³• | å®æ—¶æ€§ | æœ€ä¼˜æ€§ | å‚æ•°è°ƒä¼˜ | åŠ¨æ€éšœç¢ | é€‚ç”¨åœºæ™¯ |
|------|--------|--------|---------|---------|---------|
| **DWA** | é«˜ | å±€éƒ¨æœ€ä¼˜ | ä¸­ç­‰ | ä¸€èˆ¬ | å®¤å†…å¯¼èˆª |
| **åŠ¿åœºæ³•** | æœ€é«˜ | æ— ä¿è¯ | ç®€å• | è¾ƒå·® | ç®€å•ç¯å¢ƒ |
| **MPC** | ä¸­ | è¾ƒä¼˜ | å¤æ‚ | å¥½ | ç²¾ç¡®æ§åˆ¶ |
| **æ·±åº¦å­¦ä¹ ** | é«˜ | ä¾èµ–è®­ç»ƒ | å›°éš¾ | è¾ƒå¥½ | å¤æ‚ç¯å¢ƒ |

### 6.2 é€‰æ‹©æŒ‡å—

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  é¿éšœç®—æ³•é€‰æ‹©                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  å®æ—¶æ€§è¦æ±‚é«˜ï¼Ÿ                                              â”‚
â”‚     â”œâ”€â”€ æ˜¯ â†’ åŠ¿åœºæ³• / ç®€åŒ–DWA                              â”‚
â”‚     â””â”€â”€ å¦ â†’ MPC                                           â”‚
â”‚                                                             â”‚
â”‚  æœ‰åŠ¨æ€éšœç¢ç‰©ï¼Ÿ                                              â”‚
â”‚     â”œâ”€â”€ æ˜¯ â†’ MPC / æ·±åº¦å­¦ä¹                                 â”‚
â”‚     â””â”€â”€ å¦ â†’ DWA / åŠ¿åœºæ³•                                  â”‚
â”‚                                                             â”‚
â”‚  éœ€è¦è€ƒè™‘æœºå™¨äººåŠ¨åŠ›å­¦ï¼Ÿ                                      â”‚
â”‚     â”œâ”€â”€ æ˜¯ â†’ MPC                                           â”‚
â”‚     â””â”€â”€ å¦ â†’ DWA / åŠ¿åœºæ³•                                  â”‚
â”‚                                                             â”‚
â”‚  æœ‰å¤§é‡è®­ç»ƒæ•°æ®ï¼Ÿ                                            â”‚
â”‚     â”œâ”€â”€ æ˜¯ â†’ æ·±åº¦å­¦ä¹                                       â”‚
â”‚     â””â”€â”€ å¦ â†’ ä¼ ç»Ÿæ–¹æ³•                                      â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.3 å®é™…åº”ç”¨å»ºè®®

1. **å®¤å†…æœåŠ¡æœºå™¨äºº**ï¼šDWA + å±€éƒ¨è§„åˆ’å™¨
2. **è‡ªåŠ¨é©¾é©¶**ï¼šMPC + å†³ç­–å±‚
3. **æ— äººæœº**ï¼šåŠ¿åœºæ³• + è½¨è¿¹è·Ÿè¸ª
4. **å¤æ‚ç¯å¢ƒ**ï¼šæ·±åº¦å­¦ä¹  + ä¼ ç»Ÿæ–¹æ³•èåˆ

---

## å»¶ä¼¸é˜…è¯»

### è®ºæ–‡
- "The Dynamic Window Approach to Collision Avoidance" - Fox et al.
- "Model Predictive Control for Autonomous and Semiautonomous Vehicles"

### å¼€æºå®ç°
- **ROS Navigation Stack**: DWAå®ç°
- **CVXGEN**: MPCä»£ç ç”Ÿæˆå™¨

---

*æœ¬ç« èŠ‚æŒç»­æ›´æ–°ä¸­...*
